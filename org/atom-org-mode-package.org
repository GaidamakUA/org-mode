
* Atom org-mode Package

In order to maintain compatibility, the Atom =org-mode= package will follow the syntax specification[fn:1][fn:2] provided on [[http://orgmode.org][orgmode.org]].

* Package Files

- [[file:../coffeelint.json][coffeelint.json]]

  # Link to [[file:atom-org-mode-package.org::coffeelint.json][coffeelint.json Section]]

- [[file:../spec/org-mode-spec.coffee][org-mode-spec.coffee]]

  # Link to [[file:atom-org-mode-package.org::org-mode-spec.coffee][org-mode-spec.coffee Section]]

- [[file:../grammars/org-mode.cson][org-mode.cson]]

  # Link to [[file:atom-org-mode-package.org::org-mode.cson][org-mode.cson Section]]

- [[file:../styles/org-mode.less][org-mode.less]]

  # Link to [[file:atom-org-mode-package.org::org-mode.less][shell-unix-bash-org-mode.less Section]]

- [[file:../package.json][package.json]]

  # Link to [[file:atom-org-mode-package.org::package.json][package.json Section]]

- [[file:../README.md][README.md]]

  # Link to [[file:atom-org-mode-package.org::README.md][README.md Section]]

- [[file:../grammars/shell-unix-bash-org-mode.cson][shell-unix-bash-org-mode.cson]]

  # Link to [[file:atom-org-mode-package.org::shell-unix-bash-org-mode.cson][shell-unix-bash-org-mode.cson Section]]

* Exported Files                                                   :noexport:

** coffeelint.json                                                :noexport:
:PROPERTIES:
:ID:       05A40356-D779-4E4B-9DDB-14D86B00ED74
:END:

# Tangle file with C-u C-c C-v t

#+BEGIN_SRC javascript :eval never :tangle ../coffeelint.json 
  {
    "max_line_length": {
      "level": "ignore"
    },
    "no_empty_param_list": {
      "level": "error"
    },
    "arrow_spacing": {
      "level": "error"
    },
    "no_interpolation_in_single_quotes": {
      "level": "error"
    },
    "no_debugger": {
      "level": "error"
    },
    "prefer_english_operator": {
      "level": "error"
    },
    "colon_assignment_spacing": {
      "spacing": {
        "left": 0,
        "right": 1
      },
      "level": "error"
    },
    "braces_spacing": {
      "spaces": 0,
      "level": "error"
    },
    "spacing_after_comma": {
      "level": "error"
    },
    "no_stand_alone_at": {
      "level": "error"
    }
  }
#+END_SRC

** grammars

*** org-mode.cson
:PROPERTIES:
:ID:       93C158C1-6209-4A22-9C45-0E46CD7DE030
:END:

# Tangle file with C-u C-c C-v t

#+BEGIN_SRC javascript :eval never :tangle ../grammars/org-mode.cson :mkdirp yes :noweb yes 
  'name': 'Org-Mode Syntax'
  'scopeName': 'source.org-mode'
  'limitLineLength': false
  'fileTypes': [
    'org-mode'
    'org'
  ]
  'patterns': [
    {
      'include': '#comment-line'
    }
    {
      'include': '#comment-block'
    }
    {
      'include': '#example-line'
    }
    {
      'include': '#example-block'
    }
    {
      'include': '#quote-block'
    }
    {
      'include': '#user-defined-block'
    }
    {
      'include': '#object-links'
    }
    {
      'include': '#verbatim'
    }
    {
      'include': '#code'
    }
    {
      'include': '#emphasis'
    }
    {
      'include': '#code-block-shell'
    }
    {
      'include': '#code-block-ruby'
    }
    {
      'include': '#code-block-python'
    }
    {
      'include': '#code-block-sql'
    }
    {
      'include': '#code-block-css'
    }
    {
      'include': '#options-line'
    }
    {
      'include': '#keywords-line'
    }
    {
      'include': '#babel-call'
    }
    {
      'begin': '^(-----BEGIN PGP MESSAGE-----)$'
      'end': '^(-----END PGP MESSAGE-----)$'
      'name': 'crypt.pgp.message.string.org-mode'
      'beginCaptures':
        '1':
          'name': 'crypt.pgp.message.begin.string.org-mode'
      'endCaptures':
        '1':
          'name': 'crypt.pgp.message.begin.string.org-mode'
      'patterns': [
      ]
    }
    {
      'match': '^(\\s*\\d+\\.)(\\s+)(([\\\[])([ X-])([\\\]])(\\s))?'
      'captures':
        '1':
          'name': 'variable.ordered.list.org-mode'
        '2':
          'name': 'punctuation.definition.list.space.org-mode'
        '3':
          'name': 'variable.checkbox.list.org-mode'
        '4':
          'name': 'punctuation.definition.checkbox.begin.list.org-mode'
        '5':
          'name': 'checkbox.string.org-mode'
        '6':
          'name': 'punctuation.definition.checkbox.end.list.org-mode'
    }
    {
      'match': '^(\\s+[*]|\\s*[+-])(\\s+)(([\\\[])([ X-])([\\\]])(\\s))?'
      'captures':
        '1':
          'name': 'variable.unordered.list.org-mode'
        '2':
          'name': 'punctuation.definition.list.space.org-mode'
        '3':
          'name': 'variable.checkbox.list.org-mode'
        '4':
          'name': 'punctuation.definition.checkbox.begin.list.org-mode'
        '5':
          'name': 'checkbox.string.org-mode'
        '6':
          'name': 'punctuation.definition.checkbox.end.list.org-mode'
    }
    {
      'begin': '^(?:[ \\t]*)(\\|)'
      'end': '(\\|)?(?:\\s*)$'
      'beginCaptures':
        '1':
          'name': 'border.pipe.outer.org-mode'
      'endCaptures':
        '1':
          'name': 'border.pipe.outer.org-mode'
      'name': 'table.grmtsts'
      'patterns': [
        {
          'match': '(-+(?=[-+|]))([+]?)'
          'captures':
            '1':
              'name': 'border.header.org-mode'
            '2':
              'name': 'border.header.org-mode'
        }
        {
          'match': '\\|'
          'name': 'border.pipe.inner.org-mode'
        }
      ]
    }
    {
      'begin': '^(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-1.org-mode'
      'captures':
        '1':
          'name': 'markup.heading.marker.org-mode'
        '2':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
        {
          'include': '#task-status'
        }
        {
          'include': '#code'
        }
        {
          'include': '#verbatim'
        }
        {
          'include': '#emphasis'
        }
        {
          'include': '#object-links'
        }
      ]
    }
    {
      'begin': '^(\\*{1})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-2.org-mode'
      'captures':
        '1':
          'name': 'leading-star.star-1.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
        {
          'include': '#task-status'
        }
        {
          'include': '#code'
        }
        {
          'include': '#verbatim'
        }
        {
          'include': '#emphasis'
        }
        {
          'include': '#object-links'
        }
      ]
    }
    {
      'begin': '^(\\*{2})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-3.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
        {
          'include': '#task-status'
        }
        {
          'include': '#code'
        }
        {
          'include': '#verbatim'
        }
        {
          'include': '#emphasis'
        }
        {
          'include': '#object-links'
        }
      ]
    }
    {
      'begin': '^(\\*{3})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-4.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
        {
          'include': '#task-status'
        }
        {
          'include': '#code'
        }
        {
          'include': '#verbatim'
        }
        {
          'include': '#emphasis'
        }
        {
          'include': '#object-links'
        }
      ]
    }
    {
      'begin': '^(\\*{4})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-5.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
          {
            'include': '#task-status'
          }
          {
            'include': '#code'
          }
          {
            'include': '#verbatim'
          }
          {
            'include': '#emphasis'
          }
          {
            'include': '#object-links'
          }
        ]
    }
    {
      'begin': '^(\\*{5})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-6.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
          {
            'include': '#task-status'
          }
          {
            'include': '#code'
          }
          {
            'include': '#verbatim'
          }
          {
            'include': '#emphasis'
          }
          {
            'include': '#object-links'
          }
        ]
    }
    {
      'begin': '^(\\*{6})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-7.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
          {
            'include': '#task-status'
          }
          {
            'include': '#code'
          }
          {
            'include': '#verbatim'
          }
          {
            'include': '#emphasis'
          }
          {
            'include': '#object-links'
          }
        ]
    }
    {
      'begin': '^(\\*{7})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-8.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
          {
            'include': '#task-status'
          }
          {
            'include': '#code'
          }
          {
            'include': '#verbatim'
          }
          {
            'include': '#emphasis'
          }
          {
            'include': '#object-links'
          }
        ]
    }
    {
      'begin': '^(\\*{8})(\\*{1})(\\s+)'
      'end': '$'
      'name': 'markup.heading.heading-9.org-mode'
      'captures':
        '1':
          'name': 'leading-star.org-mode'
        '2':
          'name': 'markup.heading.marker.org-mode'
        '3':
          'name': 'markup.heading.space.org-mode'
      'patterns': [
          {
            'include': '#task-status'
          }
          {
            'include': '#code'
          }
          {
            'include': '#verbatim'
          }
          {
            'include': '#emphasis'
          }
          {
            'include': '#object-links'
          }
        ]
    }
  ]
  'repository':

    'comment-line':
      'patterns': [
        {
          'begin': '^\\s*#\\s'
          'end': '$'
          'captures':
            '0':
              'name': 'punctuation.definition.comment.org-mode'
          'name': 'comment.line.org-mode'
        }
      ]

    'comment-block':
      'patterns': [
        {
          'begin': '^(?i:\\s*#\\+BEGIN_COMMENT\\s*)'
          'captures':
            '0':
              'name': 'punctuation.definition.comment.org-mode'
          'end': '^(?i:\\s*#\\+END_COMMENT\\s*)'
          'name': 'comment.block.org-mode'
        }
      ]

    'example-line':
      'patterns': [
        {
          'begin': '^\\s*:\\s'
          'end': '$'
          'captures':
            '0':
              'name': 'punctuation.definition.string.org-mode'
          'name': 'string.unquoted.org-mode'
        }
      ]

    'example-block':
      'patterns':[
          {
            'begin': '^(?i:\\s*#\\+BEGIN_EXAMPLE\\s*)'
            'beginCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'end': '^(?i:\\s*#\\+END_EXAMPLE\\s*)'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'string.unquoted.org-mode'
          }
      ]

    'quote-block':
      'patterns': [
        {
          'begin': '^(?i:\\s*#\\+BEGIN_QUOTE\\s*)'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.quote.org-mode'
          'end': '^(?i:\\s*#\\+END_QUOTE\\s*)'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.quote.org-mode'
          'contentName': 'markup.quote.org-mode'
          'patterns': [
            {
              'include': '#emphasis'
            }
            {
              'include': '#object-links'
            }
          ]
        }
      ]

    'unordered-list':
      'patterns': [
          {
            'match': '^\\s+([*+-])(\\s+)'
            'captures':
              '1':
                'name': 'punctuation.definition.item.org-mode'
              '2':
                'name': 'punctuation.definition.item.space.org-mode'
          }
      ]

    'emphasis':
      'patterns':[
        {
          'include': '#bold'
        }
        {
          'include': '#italic'
        }
        {
          'include': '#underline'
        }
        {
          'include': '#strike-through'
        }
      ]

    'task-status-todo':
        'patterns': [
            {
              'match': '(?<=[\\\*]\\s)(TODO)\\b'
              'name': 'constant.task.status.todo.org-mode'
            }
        ]

    'task-status-done':
        'patterns': [
            {
              'match': '(?<=[\\\*]\\s)(DONE)\\b'
              'name': 'constant.task.status.done.org-mode'
            }
        ]

    'task-status':
        'patterns': [
            {
              'include': '#task-status-todo'
            }
            {
              'include': '#task-status-done'
            }
        ]

    'code':
        'patterns': [
          {
            'begin': '(?<=^|[^\\w\\d\\~])(\\~)(?!$|\\~|\\s)'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'end': '(?<!^|\\s)(\\~)(?=$|[^\\w|\\d])'
            'endCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'name': 'markup.raw.code.line.org-mode'

          }
      ]

    'verbatim':
        'patterns': [
          {
            'begin': '(?<=^|[^\\w\\d\\=])(\\=)(?!$|\\=|\\s)'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'end': '(?<!^|\\s)(\\=)(?=$|[^\\w|\\d])'
            'endCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'name': 'markup.raw.verbatim.org-mode'
          }
      ]

    'bold':
        'patterns': [
          {
            'begin': '(?<=^|[^\\w\\d\\*])(\\*)(?!$|\\*|\\s)'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'end': '(?<!^|\\s)(\\*)(?=$|[^\\w|\\d])'
            'endCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'name': 'markup.bold.org-mode'
            'patterns': [
              {
                'match': '(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)'
                'name': 'constant.character.entity.org-mode'
                'captures':
                  '1':
                    'name': 'punctuation.definition.entity.org-mode'
                  '3':
                    'name': 'punctuation.definition.entity.org-mode'
              }
              {
                'include': '#italic'
              }
              {
                'include': '#underline'
              }
              {
                'include': '#strike-through'
              }
              {
                'include': '#code'
              }
              {
                'include': '#verbatim'
              }
              {
                'include': '#object-links'
              }
            ]
        }
      ]

    'underline':
      'patterns':[
         {
           'begin': '(?<=^|[^\\w\\d_])(_)(?!$|_|\\s)'
           'beginCaptures':
             '1':
               'name': 'punctuation.definition.character.org-mode'
           'end': '(?<!^|\\s)(_)(?=$|[^\\w|\\d])'
           'endCaptures':
             '1':
               'name': 'punctuation.definition.character.org-mode'
           'name': 'markup.underline.link.org-mode'
           'patterns': [
             {
               'match': '(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)'
               'name': 'constant.character.entity.org-mode'
               'captures':
                 '1':
                   'name': 'punctuation.definition.entity.org-mode'
                 '3':
                   'name': 'punctuation.definition.entity.org-mode'
             }
             {
               'include': '#bold'
             }
             {
               'include': '#italic'
             }
             {
               'include': '#strike-through'
             }
             {
               'include': '#code'
             }
             {
               'include': '#verbatim'
             }
             {
               'include': '#object-links'
             }
           ]
         }

      ]
    'italic':
      'patterns':[
        {
            'begin': '(?<=^|[^\\w\\d\\/])(\\/)(?!$|\\/|\\s)'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'end': '(?<!^|\\s)(\\/)(?=$|[^\\w|\\d])'
            'endCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'name': 'markup.italic.org-mode'
            'patterns': [
              {
                'match': '(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)'
                'name': 'constant.character.entity.org-mode'
                'captures':
                  '1':
                    'name': 'punctuation.definition.entity.org-mode'
                  '3':
                    'name': 'punctuation.definition.entity.org-mode'
              }
              {
                'include': '#bold'
              }
              {
                'include': '#underline'
              }
              {
                'include': '#strike-through'
              }
              {
                'include': '#code'
              }
              {
                'include': '#verbatim'
              }
              {
                'include': '#object-links'
              }
            ]
          }
      ]

    'strike-through':
      'patterns': [
          {
            'begin': '(?<=^|[^\\w\\d#\\+])(\\+)(?!$|\\+|\\s)'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'end': '(?<!^|\\s)(\\+)(?=$|[^\\w|\\d])'
            'endCaptures':
              '1':
                'name': 'punctuation.definition.character.org-mode'
            'name': 'markup.strike.org-mode'
            'patterns': [
              {
                'match': '(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)'
                'name': 'constant.character.entity.org-mode'
                'captures':
                  '1':
                    'name': 'punctuation.definition.entity.org-mode'
                  '3':
                    'name': 'punctuation.definition.entity.org-mode'
              }
              {
                'include': '#bold'
              }
              {
                'include': '#italic'
              }
              {
                'include': '#underline'
              }
              {
                'include': '#code'
              }
              {
                'include': '#verbatim'
              }
              {
                'include': '#object-links'
              }
            ]
          }
      ]

    'code-block-shell':
      'patterns':[
          {
            'begin': '^(\\s*#\\+BEGIN_SRC\\s+)(sh|shell|bash)(\\s+(:\\w+)(\\s+.+)?)*$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.string.org-mode'
              '2':
                'name': 'code-block.type.org-mode'
              '3':
                'name': 'code-block.code-block-headers.org-mode'
            'end': '^(?i)(\\s*#\\+END_SRC\\s*)$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'source.embedded.shell-org-mode'
            'patterns':[
              {
                'include': 'source.shell-org-mode'
              }
            ]
          }
      ]

    'code-block-ruby':
      'patterns':[
          {
            'begin': '^(\\s*#\\+BEGIN_SRC\\s+)(ruby)(\\s+(:\\w+)(\\s+.+)?)*$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.string.org-mode'
              '2':
                'name': 'code-block.type.org-mode'
              '3':
                'name': 'code-block.code-block-headers.org-mode'
            'end': '^(?i)(\\s*#\\+END_SRC\\s*)$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'source.embedded.ruby-org-mode'
            'patterns':[
              {
                'include': 'source.ruby'
              }
            ]
          }
      ]

    'code-block-python':
      'patterns':[
          {
            'begin': '^(\\s*#\\+BEGIN_SRC\\s+)(python)(\\s+(:\\w+)(\\s+.+)?)*$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.string.org-mode'
              '2':
                'name': 'code-block.type.org-mode'
              '3':
                'name': 'code-block.code-block-headers.org-mode'
            'end': '^(?i)(\\s*#\\+END_SRC\\s*)$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'source.embedded.python-org-mode'
            'patterns':[
              {
                'include': 'source.python'
              }
            ]
          }
      ]

    'code-block-sql':
      'patterns':[
          {
            'begin': '^(\\s*#\\+BEGIN_SRC\\s+)(sql)(\\s+(:\\w+)(\\s+.+)?)*$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.string.org-mode'
              '2':
                'name': 'code-block.type.org-mode'
              '3':
                'name': 'code-block.code-block-headers.org-mode'
            'end': '^(?i)(\\s*#\\+END_SRC\\s*)$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'source.embedded.sql-org-mode'
            'patterns':[
              {
                'include': 'source.sql'
              }
            ]
          }
      ]
    'code-block-css':
      'patterns':[
          {
            'begin': '^(\\s*#\\+BEGIN_SRC\\s+)(css)(\\s+(:\\w+)(\\s+.+)?)*$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.string.org-mode'
              '2':
                'name': 'code-block.type.org-mode'
              '3':
                'name': 'code-block.code-block-headers.org-mode'
            'end': '^(?i)(\\s*#\\+END_SRC\\s*)$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'source.embedded.css-org-mode'
            'patterns':[
              {
                'include': 'source.css'
              }
            ]
          }
      ]

    'options-line':
      'patterns': [
        {
          'begin': '^(\\s*#[+])(OPTIONS|TITLE|DATE|AUTHOR|EMAIL|LANGUAGE|CREATOR|SELECT_TAGS|EXCLUDE_TAGS|SETUP|PROPERTY|MACRO)(:)((\\s+)(.+))?'
          'end': '$'
          'captures':
            '1':
              'name': 'punctuation.definition.keyword.org-mode'
            '2':
              'name': 'markup.function.keyword.key-name.org-mode'
            '3':
              'name': 'punctuation.definition.keyword.org-mode'
            '5':
              'name': 'punctuation.definition.keyword.space.org-mode'
            '6':
              'name': 'punctuation.definition.keyword.key-value.org-mode'
          'name': 'markup.keyword.org-mode'
        }
      ]

    'keywords-line':
      'patterns': [
        {
          'begin': '^(\\s*#[+])(HEADER|NAME|PLOT|CAPTION|RESULTS[\\\[\\\]a-f0-9]*)(:)((\\s+)(.+))?'
          'end': '$'
          'captures':
            '1':
              'name': 'punctuation.definition.keyword.org-mode'
            '2':
              'name': 'markup.function.keyword.key-name.org-mode'
            '3':
              'name': 'punctuation.definition.keyword.org-mode'
            '5':
              'name': 'punctuation.definition.keyword.space.org-mode'
            '6':
              'name': 'punctuation.definition.keyword.key-value.org-mode'
          'name': 'markup.keyword.org-mode'
        }
      ]

    'babel-call':
      'patterns': [
        {
          'begin': '^(\\s*#[+])(CALL[\\\[\\\]a-zA-Z0-9,]*)(:)((\\s+)(.+))?'
          'end': '$'
          'captures':
            '1':
              'name': 'punctuation.definition.keyword.org-mode'
            '2':
              'name': 'markup.function.keyword.key-name.org-mode'
            '3':
              'name': 'punctuation.definition.keyword.org-mode'
            '5':
              'name': 'punctuation.definition.keyword.space.org-mode'
            '6':
              'name': 'punctuation.definition.keyword.key-value.org-mode'
          'name': 'markup.keyword.org-mode'
        }
      ]

    'user-defined-block':
      'patterns':[
          {
            'begin': '^ *#\\+BEGIN_([\\w]+)$'
            'beginCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'end': '^ *#\\+END_\\1$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'string.unquoted.org-mode'
          }
      ]

    <<grammar-radio-links-cson()>>

    <<grammar-plain-links-cson()>>
    
    <<grammar-angle-links-cson()>>

    'object-links':
        'patterns': [
            {
              'include': '#object-angle-link'
            }
            {
              'include': '#object-plain-link'
            }
            {
              'include': '#object-radio-link'
            }
        ]

#+END_SRC

*** shell-unix-bash-org-mode.cson
:PROPERTIES:
:ID:       72AAECB5-1ECD-40D5-A38E-9DF98C7794E8
:END:

# Tangle file with C-u C-c C-v t

#+BEGIN_SRC javascript :eval never :tangle ../grammars/shell-unix-bash-org-mode.cson :mkdirp yes 
  'scopeName': 'source.shell-org-mode'
  'name': 'Shell Script - Org-Mode Syntax'
  'fileTypes': [
    'sh'
    'bash'
    'ksh'
    'zsh'
    'zsh-theme'
    'zshenv'
    'zlogin'
    'zlogout'
    'zprofile'
    'zshrc'
    'bashrc'
    'bash_aliases'
    'bash_profile'
    'bash_login'
    'profile'
    'bash_logout'
    '.textmate_init'
    'npmrc'
    'PKGBUILD'
    'install'
    'cygport'
    'bats'
    'ebuild'
  ]
  'firstLineMatch': '''(?x)
    # Hashbang
    ^\\#!.*(?:\\s|\\/)
      (?:bash|zsh|sh|tcsh|ksh|dash|ash|csh|rc)
    (?:$|\\s)
    |
    # Modeline
    (?i:
      # Emacs
      -\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)
        (?:shell-script|sh)
      (?=[\\s;]|(?<![-*])-\\*-).*?-\\*-
      |
      # Vim
      (?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\n:]+:)|:(?!\\s* set?\\s))(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\n\\\\\\s]|\\\\.)*)?)*[\\s:](?:filetype|ft|syntax)\\s*=
        sh
      (?=\\s|:|$)
    )
  '''
  'patterns': [
    {
      'include': '#comment'
    }
    {
      'include': '#pipeline'
    }
    {
      'include': '#list'
    }
    {
      'include': '#compound-command'
    }
    {
      'include': '#loop'
    }
    {
      'include': '#string'
    }
    {
      'include': '#function-definition'
    }
    {
      'include': '#variable'
    }
    {
      'include': '#interpolation'
    }
    {
      'include': '#heredoc'
    }
    {
      'include': '#herestring'
    }
    {
      'include': '#redirection'
    }
    {
      'include': '#pathname'
    }
    {
      'include': '#keyword'
    }
    {
      'include': '#support'
    }
  ]
  'repository':
    'case-clause':
      'patterns': [
        {
          'begin': '(?=\\S)'
          'end': ';;'
          'endCaptures':
            '0':
              'name': 'punctuation.terminator.case-clause.shell-org-mode'
          'name': 'meta.scope.case-clause.shell-org-mode'
          'patterns': [
            {
              'begin': '\\(|(?=\\S)'
              'beginCaptures':
                '0':
                  'name': 'punctuation.definition.case-pattern.shell-org-mode'
              'end': '\\)'
              'endCaptures':
                '0':
                  'name': 'punctuation.definition.case-pattern.shell-org-mode'
              'name': 'meta.scope.case-pattern.shell-org-mode'
              'patterns': [
                {
                  'match': '\\|'
                  'name': 'punctuation.separator.pipe-sign.shell-org-mode'
                }
                {
                  'include': '#string'
                }
                {
                  'include': '#variable'
                }
                {
                  'include': '#interpolation'
                }
                {
                  'include': '#pathname'
                }
              ]
            }
            {
              'begin': '(?<=\\))'
              'end': '(?=;;)'
              'name': 'meta.scope.case-clause-body.shell-org-mode'
              'patterns': [
                {
                  'include': '$self'
                }
              ]
            }
          ]
        }
      ]
    'comment':
      'begin': '(^\\s+)?(?<=^|\\W)(?=#)(?!#[{+])'
      'beginCaptures':
        '1':
          'name': 'punctuation.whitespace.comment.leading.shell-org-mode'
      'end': '(?!\\G)'
      'patterns': [
        {
          'begin': '#!'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.comment.shebang.shell-org-mode'
          'end': '$'
          'name': 'comment.line.number-sign.shebang.shell-org-mode'
        }
        {
          'begin': '#'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.comment.shell-org-mode'
          'end': '$'
          'name': 'comment.line.number-sign.shell-org-mode'
        }
      ]
    'compound-command':
      'patterns': [
        {
          'begin': '\\[{1,2}'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.logical-expression.shell-org-mode'
          'end': '\\]{1,2}'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.logical-expression.shell-org-mode'
          'name': 'meta.scope.logical-expression.shell-org-mode'
          'patterns': [
            {
              'include': '#logical-expression'
            }
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '\\({2}'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '\\){2}'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.other.math.shell-org-mode'
          'patterns': [
            {
              'include': '#math'
            }
          ]
        }
        {
          'begin': '\\('
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.subshell.shell-org-mode'
          'end': '\\)'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.subshell.shell-org-mode'
          'name': 'meta.scope.subshell.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=\\s|^){(?=\\s|$)'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.group.shell-org-mode'
          'end': '(?<=^|;)\\s*(})'
          'endCaptures':
            '1':
              'name': 'punctuation.definition.group.shell-org-mode'
          'name': 'meta.scope.group.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
      ]
    'function-definition':
      'patterns': [
        {
          'begin': '(?<=^|;|&|\\s)(function)\\s+([^\\s\\\\]+)(?:\\s*(\\(\\)))?'
          'beginCaptures':
            '1':
              'name': 'storage.type.function.shell-org-mode'
            '2':
              'name': 'entity.name.function.shell-org-mode'
            '3':
              'name': 'punctuation.definition.arguments.shell-org-mode'
          'end': ';|&|$'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.function.shell-org-mode'
          'name': 'meta.function.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=^|;|&|\\s)([^\\s\\\\=]+)\\s*(\\(\\))'
          'beginCaptures':
            '1':
              'name': 'entity.name.function.shell-org-mode'
            '2':
              'name': 'punctuation.definition.arguments.shell-org-mode'
          'end': ';|&|$'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.function.shell-org-mode'
          'name': 'meta.function.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
      ]
    'heredoc':
      'patterns': [
        {
          'begin': '(<<)-("|\'|)\\s*(RUBY)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(RUBY)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.ruby.shell-org-mode'
          'contentName': 'source.ruby.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.ruby'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(RUBY)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(RUBY)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.ruby.shell-org-mode'
          'contentName': 'source.ruby.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.ruby'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*(PYTHON)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(PYTHON)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.python.shell-org-mode'
          'contentName': 'source.python.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.python'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(PYTHON)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(PYTHON)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.python.shell-org-mode'
          'contentName': 'source.python.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.python'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*(APPLESCRIPT)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(APPLESCRIPT)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.applescript.shell-org-mode'
          'contentName': 'source.applescript.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.applescript'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(APPLESCRIPT)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(APPLESCRIPT)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.applescript.shell-org-mode'
          'contentName': 'source.applescript.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.applescript'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*(HTML)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(HTML)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.html.shell-org-mode'
          'contentName': 'text.html.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'text.html.basic'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(HTML)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(HTML)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.html.shell-org-mode'
          'contentName': 'text.html.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'text.html.basic'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*(MARKDOWN)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(MARKDOWN)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.markdown.shell-org-mode'
          'contentName': 'text.html.markdown.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'text.html.markdown'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(MARKDOWN)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(MARKDOWN)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.markdown.shell-org-mode'
          'contentName': 'text.html.markdown.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'text.html.markdown'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*(TEXTILE)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(TEXTILE)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.textile.shell-org-mode'
          'contentName': 'text.html.textile.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'text.html.textile'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(TEXTILE)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(TEXTILE)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.textile.shell-org-mode'
          'contentName': 'text.html.textile.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'text.html.textile'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*(SHELL)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(\\3)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'contentName': 'source.shell.embedded.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.shell.shell-org-mode'
          'patterns': [
            {
              'include': 'source.shell-org-mode'
            }
          ]
        }
        {
          'begin': '(<<)("|\'|)\\s*(SHELL)(?=\\s|;|&|<|"|\')\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(\\3)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.shell.shell-org-mode'
          'contentName': 'source.shell.embedded.shell-org-mode'
          'patterns': [
            {
              'include': 'source.shell-org-mode'
            }
          ]
        }
        {
          'begin': '(<<)-("|\'|)\\s*\\\\?([^;&<\\s]+)\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^\\t*(\\3)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.no-indent.shell-org-mode'
        }
        {
          'begin': '(<<)("|\'|)\\s*\\\\?([^;&<\\s]+)\\2'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.heredoc.shell-org-mode'
            '3':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'end': '^(\\3)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.heredoc-token.shell-org-mode'
          'name': 'string.unquoted.heredoc.shell-org-mode'
        }
      ]
    'herestring':
      'patterns': [
        {
          'begin': '(<<<)\\s*((\'))'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.herestring.shell-org-mode'
            '2':
              'name': 'string.quoted.single.shell-org-mode'
            '3':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '(\')'
          'endCaptures':
            '0':
              'name': 'string.quoted.single.shell-org-mode'
            '1':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'meta.herestring.shell-org-mode'
          'contentName': 'string.quoted.single.shell-org-mode'
        }
        {
          'begin': '(<<<)\\s*(("))'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.herestring.shell-org-mode'
            '2':
              'name': 'string.quoted.double.shell-org-mode'
            '3':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '(")'
          'endCaptures':
            '0':
              'name': 'string.quoted.double.shell-org-mode'
            '1':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'meta.herestring.shell-org-mode'
          'contentName': 'string.quoted.double.shell-org-mode'
        }
        {
          'captures':
            '1':
              'name': 'keyword.operator.herestring.shell-org-mode'
            '2':
              'name': 'string.unquoted.herestring.shell-org-mode'
              'patterns': [
                {
                  'include': '$self'
                }
              ]
          'match': '(<<<)\\s*(([^\\s)\\\\]|\\\\.)+)'
          'name': 'meta.herestring.shell-org-mode'
        }
      ]
    'interpolation':
      'patterns': [
        {
          'begin': '\\$\\({2}'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '\\){2}'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.other.math.shell-org-mode'
          'patterns': [
            {
              'include': '#math'
            }
          ]
        }
        {
          'begin': '`'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '`'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.interpolated.backtick.shell-org-mode'
          'patterns': [
            {
              'match': '\\\\[`\\\\$]'
              'name': 'constant.character.escape.shell-org-mode'
            }
            {
              # Lifted from the #comment section to handle ending on ` instead of $
              'begin': '(?<=\\W)(?=#)(?!#[{+])'
              'beginCaptures':
                '1':
                  'name': 'punctuation.whitespace.comment.leading.shell-org-mode'
              'end': '(?!\\G)'
              'patterns': [
                {
                  'begin': '#'
                  'beginCaptures':
                    '0':
                      'name': 'punctuation.definition.comment.shell-org-mode'
                  'end': '(?=`)'
                  'name': 'comment.line.number-sign.shell-org-mode'
                }
              ]
            }
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '\\$\\('
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '\\)'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.interpolated.dollar.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
      ]
    'keyword':
      'patterns': [
        {
          'match': '(?<=^|;|&|\\s)(then|else|elif|fi|for|in|do|done|select|case|continue|esac|while|until|return)(?=\\s|;|&|$)'
          'name': 'keyword.control.shell-org-mode'
        }
        {
          'match': '(?<=^|;|&|\\s)(?:export|declare|typeset|local|readonly)(?=\\s|;|&|$)'
          'name': 'storage.modifier.shell-org-mode'
        }
      ]
    'list':
      'patterns': [
        {
          'match': ';|&&|&|\\|\\|'
          'name': 'keyword.operator.list.shell-org-mode'
        }
      ]
    'logical-expression':
      'patterns': [
        {
          'comment': 'do we want a special rule for ( expr )?'
          'match': '=[=~]?|!=?|<|>|&&|\\|\\|'
          'name': 'keyword.operator.logical.shell-org-mode'
        }
        {
          'match': '(?<!\\S)-(nt|ot|ef|eq|ne|l[te]|g[te]|[a-hknoprstuwxzOGLSN])'
          'name': 'keyword.operator.logical.shell-org-mode'
        }
      ]
    'loop':
      'patterns': [
        {
          'begin': '(?<=^|;|&|\\s)(for)\\s+(?=\\({2})'
          'beginCaptures':
            '1':
              'name': 'keyword.control.shell-org-mode'
          'end': '(?<=^|;|&|\\s)done(?=\\s|;|&|$)'
          'endCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'name': 'meta.scope.for-loop.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=^|;|&|\\s)(for)\\s+(.+?)\\s+(in)(?=\\s|;|&|$)'
          'beginCaptures':
            '1':
              'name': 'keyword.control.shell-org-mode'
            '2':
              'name': 'variable.other.loop.shell-org-mode'
              'patterns': [
                {
                  'include': '#string'
                }
              ]
            '3':
              'name': 'keyword.control.shell-org-mode'
          'end': '(?<=^|;|&|\\s)done(?=\\s|;|&|$)'
          'endCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'name': 'meta.scope.for-in-loop.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=^|;|&|\\s)(while|until)(?=\\s|;|&|$)'
          'beginCaptures':
            '1':
              'name': 'keyword.control.shell-org-mode'
          'end': '(?<=^|;|&|\\s)done(?=\\s|;|&|$)'
          'endCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'name': 'meta.scope.while-loop.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=^|;|&|\\s)(select)\\s+((?:[^\\s\\\\]|\\\\.)+)(?=\\s|;|&|$)'
          'beginCaptures':
            '1':
              'name': 'keyword.control.shell-org-mode'
            '2':
              'name': 'variable.other.loop.shell-org-mode'
          'end': '(?<=^|;|&|\\s)(done)(?=\\s|;|&|$)'
          'endCaptures':
            '1':
              'name': 'keyword.control.shell-org-mode'
          'name': 'meta.scope.select-block.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=^|;|&|\\s)case(?=\\s|;|&|$)'
          'beginCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'end': '(?<=^|;|&|\\s)esac(?=\\s|;|&|$)'
          'endCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'name': 'meta.scope.case-block.shell-org-mode'
          'patterns': [
            {
              'begin': '(?<=^|;|&|\\s)in(?=\\s|;|&|$)'
              'beginCaptures':
                '0':
                  'name': 'keyword.control.shell-org-mode'
              'end': '(?<=^|;|&|\\s)(?=esac(\\s|;|&|$))'
              'name': 'meta.scope.case-body.shell-org-mode'
              'patterns': [
                {
                  'include': '#comment'
                }
                {
                  'include': '#case-clause'
                }
                {
                  'include': '$self'
                }
              ]
            }
            {
              'include': '$self'
            }
          ]
        }
        {
          'begin': '(?<=^|;|&|\\s)if(?=\\s|;|&|$)'
          'beginCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'end': '(?<=^|;|&|\\s)fi(?=\\s|;|&|$)'
          'endCaptures':
            '0':
              'name': 'keyword.control.shell-org-mode'
          'name': 'meta.scope.if-block.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
      ]
    'math':
      'patterns': [
        {
          'include': '#variable'
        }
        {
          'match': '\\+{1,2}|-{1,2}|!|~|\\*{1,2}|/|%|<[<=]?|>[>=]?|==|!=|^|\\|{1,2}|&{1,2}|\\?|\\:|,|=|[*/%+\\-&^|]=|<<=|>>='
          'name': 'keyword.operator.arithmetic.shell-org-mode'
        }
        {
          'match': '0[xX][0-9A-Fa-f]+'
          'name': 'constant.numeric.hex.shell-org-mode'
        }
        {
          'match': '0\\d+'
          'name': 'constant.numeric.octal.shell-org-mode'
        }
        {
          'match': '\\d{1,2}#[0-9a-zA-Z@_]+'
          'name': 'constant.numeric.other.shell-org-mode'
        }
        {
          'match': '\\d+'
          'name': 'constant.numeric.integer.shell-org-mode'
        }
      ]
    'pathname':
      'patterns': [
        {
          'match': '(?<=\\s|:|=|^)~'
          'name': 'keyword.operator.tilde.shell-org-mode'
        }
        {
          'match': '\\*|\\?'
          'name': 'keyword.operator.glob.shell-org-mode'
        }
        {
          'begin': '([?*+@!])(\\()'
          'beginCaptures':
            '1':
              'name': 'keyword.operator.extglob.shell-org-mode'
            '2':
              'name': 'punctuation.definition.extglob.shell-org-mode'
          'end': '\\)'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.extglob.shell-org-mode'
          'name': 'meta.structure.extglob.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
      ]
    'pipeline':
      'patterns': [
        {
          'match': '(?<=^|;|&|\\s)(time)(?=\\s|;|&|$)'
          'name': 'keyword.other.shell-org-mode'
        }
        {
          'match': '[|!]'
          'name': 'keyword.operator.pipe.shell-org-mode'
        }
      ]
    'redirection':
      'patterns': [
        {
          'begin': '[><]\\('
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '\\)'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.interpolated.process-substitution.shell-org-mode'
          'patterns': [
            {
              'include': '$self'
            }
          ]
        }
        {
          # valid: &>word >&word >word [n]>&[n] [n]<word [n]>word [n]>>word [n]<&word (last one is duplicate)
          'match': '(?<![<>])(&>|\\d*>&\\d*|\\d*(>>|>|<)|\\d*<&|\\d*<>)(?![<>])'
          'name': 'keyword.operator.redirect.shell-org-mode'
        }
      ]
    'string':
      'patterns': [
        {
          'match': '\\\\.'
          'name': 'constant.character.escape.shell-org-mode'
        }
        {
          'begin': '\''
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '\''
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.quoted.single.shell-org-mode'
        }
        {
          'begin': '\\$?"'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '"'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.quoted.double.shell-org-mode'
          'patterns': [
            {
              'match': '\\\\[\\$`"\\\\\\n]'
              'name': 'constant.character.escape.shell-org-mode'
            }
            {
              'include': '#variable'
            }
            {
              'include': '#interpolation'
            }
          ]
        }
        {
          'begin': '\\$\''
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.string.begin.shell-org-mode'
          'end': '\''
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.end.shell-org-mode'
          'name': 'string.quoted.single.dollar.shell-org-mode'
          'patterns': [
            {
              'match': '\\\\(a|b|e|f|n|r|t|v|\\\\|\')'
              'name': 'constant.character.escape.ansi-c.shell-org-mode'
            }
            {
              'match': '\\\\[0-9]{3}'
              'name': 'constant.character.escape.octal.shell-org-mode'
            }
            {
              'match': '\\\\x[0-9a-fA-F]{2}'
              'name': 'constant.character.escape.hex.shell-org-mode'
            }
            {
              'match': '\\\\c.'
              'name': 'constant.character.escape.control-char.shell-org-mode'
            }
          ]
        }
      ]
    'support':
      'patterns': [
        {
          'match': '(?<=^|;|&|\\s)(?::|\\.)(?=\\s|;|&|$)'
          'name': 'support.function.builtin.shell-org-mode'
        }
        {
          'match': '(?<=^|;|&|\\s)(?:alias|bg|bind|break|builtin|caller|cd|command|compgen|complete|dirs|disown|echo|enable|eval|exec|exit|false|fc|fg|getopts|hash|help|history|jobs|kill|let|logout|popd|printf|pushd|pwd|read|readonly|set|shift|shopt|source|suspend|test|times|trap|true|type|ulimit|umask|unalias|unset|wait)(?=\\s|;|&|$)'
          'name': 'support.function.builtin.shell-org-mode'
        }
      ]
    'variable':
      'patterns': [
        {
          'captures':
            '1':
              'name': 'punctuation.definition.variable.shell-org-mode'
          'match': '(\\$)[a-zA-Z_][a-zA-Z0-9_]*'
          'name': 'variable.other.normal.shell-org-mode'
        }
        {
          'captures':
            '1':
              'name': 'punctuation.definition.variable.shell-org-mode'
          'match': '(\\$)[-*@#?$!0_]'
          'name': 'variable.other.special.shell-org-mode'
        }
        {
          'captures':
            '1':
              'name': 'punctuation.definition.variable.shell-org-mode'
          'match': '(\\$)[1-9]'
          'name': 'variable.other.positional.shell-org-mode'
        }
        {
          'begin': '\\${'
          'beginCaptures':
            '0':
              'name': 'punctuation.definition.variable.shell-org-mode'
          'end': '}'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.variable.shell-org-mode'
          'name': 'variable.other.bracket.shell-org-mode'
          'patterns': [
            {
              'match': '!|:[-=?]?|\\*|@|\#\{1,2}|%{1,2}|/' # #{ is escaped to prevent coffeelint complaining about interpolation
              'name': 'keyword.operator.expansion.shell-org-mode'
            }
            {
              'captures':
                '1':
                  'name': 'punctuation.section.array.shell-org-mode'
                '3':
                  'name': 'punctuation.section.array.shell-org-mode'
              'match': '(\\[)([^\\]]+)(\\])'
            }
            {
              'include': '#variable'
            }
            {
              'include': '#string'
            }
          ]
        }
      ]

#+END_SRC

** package.json                                                   :noexport:

#+NAME: atom-org-mode-package-package-specs
| Property-Name | Property-Value                                                                                                               |
|---------------+------------------------------------------------------------------------------------------------------------------------------|
| name          | org-mode                                                                                                                     |
| version       | 0.3.12                                                                                                                       |
| description   | Atom grammar for org-mode syntax                                                                                             |
| keywords      | org, org-mode, org mode, orgmode, emacs, literate programming, literate devops, devops, reproducible research, documentation |
| repository    | https://github.com/melioratus/org-mode                                                                                       |
| license       | MIT                                                                                                                          |
| engines       | "atom": "&gt;=1.0.0 &lt;2.0.0"                                                                                               |
| dependencies  | "coffeescript": "1.7.0", "coffeelint": "^1.10.1", "request": "^2.34.0", "season": "^5.0.2"                                   |
#+TBLFM: @5$2='(org-sbe atom-org-mode-package-package-specs-keywords-tblfm-value)::@8$2='(org-sbe atom-org-mode-package-package-specs-engines-tblfm-value)::@9$2='(org-sbe atom-org-mode-package-package-specs-dependencies-tblfm-value)

#+BEGIN_QUOTE
  *Note:* Modify dependencies, engines, keywords, or version values by updating the tables below.
#+END_QUOTE

**** Dependencies

#+NAME: atom-org-mode-package-package-specs-dependencies
| Dependency-Name | Dependency-Versions |
|-----------------+---------------------|
| coffeescript    |               1.7.0 |
| coffeelint      |             ^1.10.1 |
| request         |             ^2.34.0 |
| season          |              ^5.0.2 |

***** Code                                                     :noexport:

#+NAME: atom-org-mode-package-package-specs-dependencies-tblfm-value
#+BEGIN_SRC ruby :var data=atom-org-mode-package-package-specs-dependencies :results verbatim    
  require 'cgi'
  result = data.map{|d| %Q'"#{d[0]}": "#{CGI::escapeHTML(d[1])}"'}
  result.join(", ")
#+END_SRC

#+RESULTS: atom-org-mode-package-package-specs-dependencies-tblfm-value
: "coffeescript": "1.7.0", "coffeelint": "^1.10.1", "request": "^2.34.0", "season": "^5.0.2"

**** Engines

#+NAME: atom-org-mode-package-package-specs-engines
| Engine-Name | Engine-Versions |
|-------------+-----------------|
| atom        | >=1.0.0 <2.0.0  |

***** Code                                                     :noexport:

#+NAME: atom-org-mode-package-package-specs-engines-tblfm-value
#+BEGIN_SRC ruby :var data=atom-org-mode-package-package-specs-engines :results verbatim    
  require 'cgi'
  result = data.map{|d| %Q'"#{d[0]}": "#{CGI::escapeHTML(d[1])}"'}
  result.join(", ")
#+END_SRC

#+RESULTS: atom-org-mode-package-package-specs-engines-tblfm-value
: "atom": "&gt;=1.0.0 &lt;2.0.0"

**** Keywords

#+NAME: atom-org-mode-package-package-specs-keywords
| Keywords              |
|-----------------------|
| org                   |
| org-mode              |
| org mode              |
| orgmode               |
| emacs                 |
| literate programming  |
| literate devops       |
| devops                |
| reproducible research |
| documentation         |

***** Code                                                     :noexport:

#+NAME: atom-org-mode-package-package-specs-keywords-tblfm-value
#+BEGIN_SRC ruby :var data=atom-org-mode-package-package-specs-keywords
  data.flatten().join(', ')
#+END_SRC

#+RESULTS: atom-org-mode-package-package-specs-keywords-tblfm-value
: org, org-mode, org mode, orgmode, emacs, literate programming, literate devops, devops, reproducible research

**** Version

The version property is updated using =apm publish= command.

#+NAME: atom-org-mode-package-package-specs-version
| Property-Name | Property-Value |
|---------------+----------------|
| version       | 0.3.12         |

***** Generate Publish Package

#+BEGIN_SRC shell :var PROPERTIES=atom-org-mode-package-package-specs-version
  echo "apm publish ${PROPERTIES['version']}"
#+END_SRC

#+RESULTS:
: apm publish 0.3.12

*** =package.json= File

#+NAME: gen-package.json
#+BEGIN_SRC ruby :file ../package.json :exports results :results scalar replace  :var keywords_data=atom-org-mode-package-package-specs-keywords :var engines_data=atom-org-mode-package-package-specs-engines :var specs_data=atom-org-mode-package-package-specs :var dependencies_data=atom-org-mode-package-package-specs-dependencies :var version_data=atom-org-mode-package-package-specs-version
  require 'json'

  result = {}
  engines_hash = {} 
  dependencies_hash = {} 

  specs_data.map{|s| result[s[0]]=s[1]}

  version_data.map{|v|
    if v[0] == 'version'
      result["version"] = v[1]
    end
  }

  result["repository"] = result["repository"].gsub(/^([\[\]]+)([^\]]+)([\]].+)$/,'\\2')

  result["keywords"] = keywords_data.flatten()

  engines_data.map{|e| engines_hash[e[0]]= e[1]}
  result["engines"] = engines_hash

  dependencies_data.map{|e| dependencies_hash[e[0]]= e[1]}
  result["dependencies"] = dependencies_hash

  JSON.pretty_generate(result)
#+END_SRC

#+RESULTS: gen-package.json
[[file:../package.json]]

** README.md                                                      :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: ../README.md
:EXPORT_OPTIONS: f:t
:END:

# Export using C-c C-e C-s m m

*** Welcome to Atom =org-mode= Package 

The [[http://org-mode.org][org-mode]] application provides an astounding set of features that can literally[fn:3] change your life for the better!  

Below is just a very small subset of things you can do using a text file + org-mode + emacs:

- Literate Programming[fn:4][fn:5] in over 30 languages. 
- Project, Task and Time Management.
- Data Science 
- Reproducible Research 
- Create and maintain documentation[fn:6] in multiple popular formats including PDF, HTML[fn:7] and Markdown.
- Track and synchronize data across heterogeneous paradigms, technologies and formats including source code, network diagrams, Infrastructure as Code, DevOps[fn:8], databases, servers and services.
- Learn new skills and share complex ideas in a consistent repeatable way.


Let us begin our journey into a better future.

**** Road Map  

 - Provide org-mode syntax highlighting to allow Atom users to easily create and maintain documentation. 

**** Specifications

#+INCLUDE: "atom-org-mode-package.org::atom-org-mode-package-package-specs"

**** Files List

- [[file:coffeelint.json][coffeelint.json]]
- [[file:spec/org-mode-spec.coffee][org-mode-spec.coffee]]
- [[file:grammars/org-mode.cson][org-mode.cson]]
- [[file:styles/org-mode.less][org-mode.less]]
- [[file:package.json][package.json]]
- [[file:grammars/shell-unix-bash-org-mode.cson][shell-unix-bash-org-mode.cson]]

** spec

*** org-mode-spec.coffee
:PROPERTIES:
:ID:       3373486E-50FB-4A83-9E04-4630A5A3DD58
:END:

#+BEGIN_SRC javascript :eval never :tangle ../spec/org-mode-spec.coffee :mkdirp yes 
  describe "org-mode package grammar", ->
    grammar = null

    beforeEach ->
      waitsForPromise ->
        atom.packages.activatePackage("org-mode")

      runs ->
        grammar = atom.grammars.grammarForScopeName("source.org-mode")

    it "parses the grammar", ->
      expect(grammar).toBeDefined()
      expect(grammar.scopeName).toBe "source.org-mode"

    it "tokenizes spaces", ->
      {tokens} = grammar.tokenizeLine(" ")
      expect(tokens[0]).toEqual value: " ", scopes: ["source.org-mode"]

    it "tokenizes single line comments", ->
      {tokens} = grammar.tokenizeLine(" # this is a comment")
      expect(tokens[0]).toEqual value: " # ", scopes: ["source.org-mode", "comment.line.org-mode","punctuation.definition.comment.org-mode"]
      expect(tokens[1]).toEqual value: "this is a comment", scopes: ["source.org-mode", "comment.line.org-mode"]

    it "tokenizes multi line comments", ->
      [firstLineTokens, secondLineTokens, thirdLineTokens, forthLineTokens] = grammar.tokenizeLines """
      ,#+BEGIN_COMMENT
      This is a
      multi line comment.
      ,#+END_COMMENT
      """
      expect(firstLineTokens[0]).toEqual value: "#+BEGIN_COMMENT", scopes: ["source.org-mode", "comment.block.org-mode", "punctuation.definition.comment.org-mode"]
      expect(secondLineTokens[0]).toEqual value: "This is a", scopes: ["source.org-mode", "comment.block.org-mode"]
      expect(thirdLineTokens[0]).toEqual value: "multi line comment.", scopes: ["source.org-mode", "comment.block.org-mode"]
      expect(forthLineTokens[0]).toEqual value: "#+END_COMMENT", scopes: ["source.org-mode", "comment.block.org-mode", "punctuation.definition.comment.org-mode"]

    it "tokenizes single line literal examples", ->
      {tokens} = grammar.tokenizeLine(" : This is a literal example on single line.")
      expect(tokens[0]).toEqual value: " : ", scopes: ["source.org-mode", "string.unquoted.org-mode", "punctuation.definition.string.org-mode"]
      expect(tokens[1]).toEqual value: "This is a literal example on single line.", scopes: ["source.org-mode", "string.unquoted.org-mode"]

    it "tokenizes multi line literal examples", ->
      [firstLineTokens, secondLineTokens, thirdLineTokens, forthLineTokens] = grammar.tokenizeLines """
      ,#+BEGIN_EXAMPLE
      This is a
      multiple line literal example.
      ,#+END_EXAMPLE
      """
      expect(firstLineTokens[0]).toEqual value: "#+BEGIN_EXAMPLE", scopes: ["source.org-mode", "punctuation.definition.string.org-mode"]
      expect(secondLineTokens[0]).toEqual value: "This is a", scopes: ["source.org-mode", "string.unquoted.org-mode"]
      expect(thirdLineTokens[0]).toEqual value: "multiple line literal example.", scopes: ["source.org-mode", "string.unquoted.org-mode"]
      expect(forthLineTokens[0]).toEqual value: "#+END_EXAMPLE", scopes: ["source.org-mode", "punctuation.definition.string.org-mode"]

    it "tokenizes multi line quote blocks", ->
      [firstLineTokens, secondLineTokens, thirdLineTokens, forthLineTokens] = grammar.tokenizeLines """
      ,#+BEGIN_QUOTE
      This is a
      multiple line quote.
      ,#+END_QUOTE
      """
      expect(firstLineTokens[0]).toEqual value: "#+BEGIN_QUOTE", scopes: ["source.org-mode", "punctuation.definition.quote.org-mode"]
      expect(secondLineTokens[0]).toEqual value: "This is a", scopes: ["source.org-mode", "markup.quote.org-mode"]
      expect(thirdLineTokens[0]).toEqual value: "multiple line quote.", scopes: ["source.org-mode", "markup.quote.org-mode"]
      expect(forthLineTokens[0]).toEqual value: "#+END_QUOTE", scopes: ["source.org-mode", "punctuation.definition.quote.org-mode"]


    it "tokenizes shell code blocks", ->
      [firstLineTokens, secondLineTokens, thirdLineTokens, forthLineTokens, fifthLineTokens, sixthLineTokens] = grammar.tokenizeLines """
      ,#+NAME: shell-code
      ,#+BEGIN_SRC shell :eval never :noweb yes
      VARIABLE_NAME=`hostname`
      echo ${VARIABLE_NAME}
      ,#+END_SRC
      # Comment below shell-code
      """
      # Disabled # expect(firstLineTokens[0]).toEqual value: "#+NAME: shell-code", scopes: ["source.org-mode"]
      expect(secondLineTokens[0]).toEqual value: "#+BEGIN_SRC ", scopes: ["source.org-mode", "punctuation.definition.string.org-mode"]
      expect(secondLineTokens[1]).toEqual value: "shell", scopes: ["source.org-mode", "code-block.type.org-mode"]
      expect(secondLineTokens[2]).toEqual value: " :eval never :noweb yes", scopes: ["source.org-mode", "code-block.code-block-headers.org-mode"]
      # Disabled # expect(secondLineTokens[3]).toEqual value: "This is a", scopes: ["source.org-mode", "bc4"]
      # Disabled # expect(secondLineTokens[4]).toEqual value: "This is a", scopes: ["source.org-mode", "bc5"]
      expect(thirdLineTokens[0]).toEqual value: "VARIABLE_NAME=", scopes: ["source.org-mode", "source.embedded.shell-org-mode"]
      expect(thirdLineTokens[1]).toEqual value: "`", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "string.interpolated.backtick.shell-org-mode", "punctuation.definition.string.begin.shell-org-mode"]
      expect(thirdLineTokens[2]).toEqual value: "hostname", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "string.interpolated.backtick.shell-org-mode"]
      expect(thirdLineTokens[3]).toEqual value: "`", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "string.interpolated.backtick.shell-org-mode", "punctuation.definition.string.end.shell-org-mode"]
      expect(forthLineTokens[0]).toEqual value: "echo", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "support.function.builtin.shell-org-mode"]
      expect(forthLineTokens[1]).toEqual value: " ", scopes: ["source.org-mode", "source.embedded.shell-org-mode"]
      expect(forthLineTokens[2]).toEqual value: "${", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "variable.other.bracket.shell-org-mode", "punctuation.definition.variable.shell-org-mode"]
      expect(forthLineTokens[3]).toEqual value: "VARIABLE_NAME", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "variable.other.bracket.shell-org-mode"]
      expect(forthLineTokens[4]).toEqual value: "}", scopes: ["source.org-mode", "source.embedded.shell-org-mode", "variable.other.bracket.shell-org-mode", "punctuation.definition.variable.shell-org-mode"]
      expect(fifthLineTokens[0]).toEqual value: "#+END_SRC", scopes: ["source.org-mode", "punctuation.definition.string.org-mode"]
      expect(sixthLineTokens[0]).toEqual value: "# ", scopes: ["source.org-mode", "comment.line.org-mode", "punctuation.definition.comment.org-mode"]
      expect(sixthLineTokens[1]).toEqual value: "Comment below shell-code", scopes: ["source.org-mode", "comment.line.org-mode"]



    it "tokenizes heading 9", ->
      [firstLineTokens, secondLineTokens, thirdLineTokens, forthLineTokens] = grammar.tokenizeLines """
      ,********* Heading 9
      Body of Heading - Line 1
      ,* Another Heading
      """
      expect(firstLineTokens[0]).toEqual value: "********", scopes: ["source.org-mode", "markup.heading.heading-9.org-mode", "leading-star.org-mode"]
      expect(firstLineTokens[1]).toEqual value: "*", scopes: ["source.org-mode", "markup.heading.heading-9.org-mode", "markup.heading.marker.org-mode"]
      expect(firstLineTokens[2]).toEqual value: " ", scopes: ["source.org-mode", "markup.heading.heading-9.org-mode", "markup.heading.space.org-mode"]
      expect(firstLineTokens[3]).toEqual value: "Heading 9", scopes: ["source.org-mode", "markup.heading.heading-9.org-mode"]
      expect(secondLineTokens[0]).toEqual value: "Body of Heading - Line 1", scopes: ["source.org-mode"]
      expect(thirdLineTokens[0]).toEqual value: "*", scopes: ["source.org-mode", "markup.heading.heading-1.org-mode", "markup.heading.marker.org-mode"]

  #
  #   it "tokenizes heading 8", ->
  #     [firstLineTokens, secondLineTokens, thirdLineTokens, forthLineTokens, fifthLineTokens] = grammar.tokenizeLines """
  #     ******** Heading 8
  #     Body of Heading - Line 1
  #     ********* Heading 9
  #     Body of Heading - Line 1
  #     * Another Heading
  #     """
  #     expect(firstLineTokens[0]).toEqual value: "********", scopes: ["source.org-mode", "markup.heading.heading-8.org-mode", "punctuation.definition.markup.heading.heading-8.begin.org-mode"]
  #     expect(firstLineTokens[1]).toEqual value: " ", scopes: ["source.org-mode", "markup.heading.heading-8.org-mode", "punctuation.definition.markup.heading.spaces.org-mode"]
  #     expect(firstLineTokens[2]).toEqual value: "Heading 8", scopes: ["source.org-mode", "markup.heading.heading-8.org-mode", "markup.heading.org-mode"]
  #     expect(secondLineTokens[0]).toEqual value: "Body of Heading - Line 1", scopes: ["source.org-mode", "markup.heading.heading-8.org-mode", 'meta.section.block']
  #     expect(thirdLineTokens[0]).toEqual value: "#+END_QUOTE", scopes: ["source.org-mode", "text.plain.embedded.org-mode", "punctuation.definition.string.org-mode"]
  #     expect(forthLineTokens[0]).toEqual value: "* ", scopes: ["source.org-mode", "markup.heading.heading-8.org-mode", "punctuation.definition.markup.heading.heading-8.end.org-mode"]

#+END_SRC

** styles

*** org-mode.less
:PROPERTIES:
:ID:       845DF488-2DEB-4F11-911C-D036DDDF66DC
:END:

# Tangle file with C-u C-c C-v t

#+BEGIN_SRC css  :eval never :tangle ../styles/org-mode.less :mkdirp yes 
  // The ui-variables file is provided by base themes provided by Atom.
  //
  // See https://github.com/atom/atom-dark-ui/blob/master/styles/ui-variables.less
  // for a full listing of what's available.
  @import "ui-variables";

  @default-very-light-gray: #c5c8c6;
  @default-light-gray: #969896;
  @default-gray: #373b41;
  @default-dark-gray: #282a2e;
  @default-very-dark-gray: #1d1f21;

  @default-cyan: cyan;
  @default-blue: blue;
  @default-purple: purple;
  @default-green: green;
  @default-red: red;
  @default-orange: orange;
  @default-light-orange: #ffd280;


  .grammar-tests {
  }


  .syntax--bold.syntax--org-mode  {
    color: lighten(@syntax-text-color, 15%);
    font-weight: bold;
  }

  .syntax--italic.syntax--org-mode  {
    // color: lighten(@syntax-text-color, 15%);
    font-style: italic;
  }

  .syntax--underline.syntax--org-mode  {
    // color: lighten(@syntax-text-color, 15%);
    text-decoration: underline;
  }

  .syntax--strike.syntax--org-mode  {
    // color: lighten(@default-red, 25%);
    text-decoration: line-through;
    font-weight: 100;
  }

  .syntax--leading-star.syntax--org-mode  {
    color: @syntax-invisible-character-color;
    &:hover {
      color: multiply(@syntax-invisible-character-color, @syntax-invisible-character-color);
    }
  }

  .syntax--heading-1.syntax--org-mode  {
     font-weight: bolder;
  }

   .syntax--heading-2.syntax--org-mode  {
     font-weight: bolder;
  }

  .syntax--heading-3.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--heading-4.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--heading-5.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--heading-6.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--heading-7.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--heading-8.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--heading-9.syntax--org-mode  {
    font-weight: bolder;
  }

  .syntax--variable.syntax--checkbox.syntax--list.syntax--org-mode {
    font-weight: bolder;
  }

  .syntax--variable.syntax--ordered.syntax--list.syntax--org-mode {
    // color: darken(@syntax-text-color, 11%);
    font-weight: 500;
    &:hover {
      font-weight: bolder;
    }
  }

  .syntax--variable.syntax--unordered.syntax--list.syntax--org-mode {
    // color: darken(@syntax-text-color, 11%);
    font-weight: 500;
    &:hover {
      font-weight: bolder;
    }
  }

  .syntax--constant.syntax--task.syntax--status.syntax--todo.syntax--org-mode {
    //color: darken(@syntax-background-color, 15%);
    background-color: darken(@syntax-background-color, 5%);
    font-family: monospace;
    padding-left: 5px;
    padding-right: 5px;
    border-radius: 5px;
  }

  .syntax--constant.syntax--task.syntax--status.syntax--done.syntax--org-mode {
    color: @syntax-invisible-character-color;
    background-color: darken(@syntax-background-color, 1%);
    font-family: monospace;
    padding-left: 5px;
    padding-right: 5px;
    border-radius: 5px;
  }

  .syntax--punctuation.syntax--definition.syntax--quote.syntax--org-mode {

    color: @syntax-invisible-character-color;

    &:hover {
      color: multiply(@syntax-invisible-character-color, @syntax-invisible-character-color);
    }
  }

  .syntax--markup.syntax--quote.syntax--org-mode {
     font-weight: 100;
     color: darken(@syntax-text-color, 20%);
     &::before {
       content: "  ";
     }
  }

  .syntax--string.syntax--unquoted.syntax--org-mode {
    font-weight: 100;
    color: @syntax-text-color;
  }

  .syntax--punctuation.syntax--definition.syntax--string.syntax--org-mode {
    color: @syntax-invisible-character-color;

    &:hover {
      color: multiply(@syntax-invisible-character-color, @syntax-invisible-character-color);
    }
  }

  // punctuation.definition.entity
  .syntax--punctuation.syntax--definition.syntax--character.syntax--org-mode {
    color: @syntax-invisible-character-color;
    font-style: normal;
    font-weight: 100;

    &:hover {
      color: multiply(@syntax-invisible-character-color, @syntax-invisible-character-color);
    }
  }

  .syntax--markup.syntax--code.syntax--line.syntax--org-mode {
    font-family: serif;
    // font-weight: lighter;
  }

  .syntax--markup.syntax--verbatim.syntax--org-mode {
    // color: lighten(blue, 20%);
    font-family: monospace;
  }
  .syntax--border.syntax--pipe.syntax--outer {
    color: multiply(@syntax-invisible-character-color, gray);
    font-weight: bold;
  }
  .syntax--border.syntax--header {
    color: multiply(@syntax-invisible-character-color, gray);
    font-weight: bold;
    text-decoration: line-through;
  }

  .syntax--border.syntax--pipe.syntax--inner {
    color: multiply(@syntax-invisible-character-color, gray);
    font-weight: bold;
  }

  .syntax--table {
      // background-color: lighten(@syntax-background-color, 2%);
  }

  .syntax--code-block.syntax--type.syntax--org-mode {
    color: @syntax-invisible-character-color;
    font-style: italic;
    &:hover {
      color: multiply(@syntax-invisible-character-color, @syntax-invisible-character-color);
      font-style: normal;
      font-weight: bold;
    }

  }

  .syntax--code-block.syntax--code-block-headers.syntax--org-mode {
    color: @syntax-invisible-character-color;
    font-style: italic;
    &:hover {
      color: multiply(@syntax-invisible-character-color, @syntax-invisible-character-color);
      font-style: normal;
    }

  }
#+END_SRC

* Notes

** Node Setup                                                     :noexport:

** Atom Editor                                                    :noexport:

*** Marker

#+BEGIN_SRC javascript :eval never
  var myMrk = myTE.buffer.markRange(myRange)
  //undefined
  myMrk.isValid()
  //true
  var myDecorator = myTE.decorateMarker(myMrk,{type: 'line', class:'icon icon-alert'})
  //undefined
  myMrk.destroy()
  //Object {}
#+END_SRC

** Org-Syntax[fn:9][fn:10]

*** Headlines and Sections
  :PROPERTIES:
  :CUSTOM_ID: Headlines_and_Sections
  :ID:       FD0F02FE-459C-4268-B4B8-AA82ECC75FFD
  :END:

  A headline is defined as:

  #+NAME: org-syntax-headline-definition
  #+BEGIN_EXAMPLE
  STARS KEYWORD PRIORITY TITLE TAGS
  #+END_EXAMPLE

  #+NAME: org-syntax-stars-definition
  STARS is a string starting at column 0, containing at least one
  asterisk (and up to ~org-inlinetask-min-level~ if =org-inlinetask=
  library is loaded) and ended by a space character.  The number of
  asterisks is used to define the level of the headline.  It's the
  sole compulsory part of a headline.

  #+NAME: org-syntax-keyword-definition
  KEYWORD is a TODO keyword, which has to belong to the list defined
  in ~org-todo-keywords-1~.  Case is significant.

  #+NAME: org-syntax-priority-definition
  PRIORITY is a priority cookie, i.e. a single letter preceded by
  a hash sign # and enclosed within square brackets.
  
  #+NAME: org-syntax-title-definition
  TITLE can be made of any character but a new line.  Though, it will
  match after every other part have been matched.
  
  #+NAME: org-syntax-tags-definition  
  TAGS is made of words containing any alpha-numeric character,
  underscore, at sign, hash sign or percent sign, and separated with
  colons.
    
  Examples of valid headlines include:

  #+NAME: examples-of-valid-headlines.org
  #+BEGIN_SRC org :tangle ../samples/examples-of-valid-headlines.org :results org replace 
  ,*

  ,** DONE

  ,*** Some e-mail

  ,**** TODO [#A] COMMENT Title :tag:a2%:
  #+END_SRC
  
  #+NAME: org-syntax-title-comment-definition  
  If the first word appearing in the title is "COMMENT", the headline
  will be considered as "commented".  Case is significant.
  
  #+NAME: org-syntax-title-footnote-section-definition
  If its title is ~org-footnote-section~, it will be considered as
  a "footnote section".  Case is significant.

  #+NAME: org-syntax-tags-archive-definition
  If "ARCHIVE" is one of its tags, it will be considered as
  "archived".  Case is significant.

  A headline contains directly one section (optionally), followed by
  any number of deeper level headlines.

  A section contains directly any greater element or element.  Only
  a headline can contain a section.  As an exception, text before the
  first headline in the document also belongs to a section.

  As an example, consider the following document:

  #+NAME: org-syntax-example-document1.org
  #+BEGIN_SRC org :tangle ../samples/org-syntax-example-document1.org :results org replace
  An introduction.
  
  ,* A Headline 
  
    Some text.
  
  ,** Sub-Topic 1
  
  ,** Sub-Topic 2
  
  ,*** Additional entry 
  #+END_SRC

  Its internal structure could be summarized as:

  #+BEGIN_EXAMPLE
  (document
   (section)
   (headline
    (section)
    (headline)
    (headline
     (headline))))
  #+END_EXAMPLE

**** Code  

***** Regular Expressions

****** Headline Regular Expressions

#+NAME: headline-regex-js
#+BEGIN_SRC org :noweb yes :results verbatim replace :exports both :wrap EXAMPLE :exports both
  <<STARS>>(<<KEYWORD>>?<<PRIORITY>>?<<TITLE>>?<<TAGS>>?|\s)
#+END_SRC

#+RESULTS: headline-regex-js
#+BEGIN_EXAMPLE
^([*]+(?=\s))(( ?(TODO|DONE))?( +(\[#[a-zA-Z]\]))?( +(.+))?( +(([:\w@#%]+))+)?|\s)
#+END_EXAMPLE

#+NAME: headline-regex-js-elisp
#+BEGIN_SRC elisp
  (concat (org-sbe STARS) (org-sbe KEYWORD) "?" (org-sbe PRIORITY) "?" (org-sbe TITLE) "?" (org-sbe TAGS) "?")
#+END_SRC

#+RESULTS: headline-regex-js-elisp
: ^([*]+(?=\s))(( +)(TODO|DONE))?(( +)(\[#[a-zA-Z]\]))?(( +)(.+))?(( +)(([:\w@#%]+))+)?

#+CALL: elisp/display-this-here(data=org-syntax-headline-definition)

#+RESULTS:
: STARS KEYWORD PRIORITY TITLE TAGS

: ^([*]+)( ?(TODO|DONE)? ?(\\[#[a-zA-Z]\\])?( (.+))( (([:\\w@#%]+))+)?)?
: ^([*]+)( ?(TODO|DONE)? ?(\\[#[a-zA-Z]\\])?( (.+)?)( (([:\\w@#%]+))+)?)?
: ^([*]+)( +(TODO|DONE)?( +(\\[#[a-zA-Z]\\]))?( +(.+))?( +(([:\\w@#%]+))+))
: ^([*]+)( +(TODO|DONE)?( +(\\[#[a-zA-Z]\\]))?( +(.+))?( +(([:\\w@#%]+))+))
: ^([*]+)( +(TODO|DONE)?( +(\\[#[a-zA-Z]\\]))?( +(.+))?( +(([:\\w@#%]+))+))?


*Headline Test 1 String*
#+NAME: headline-test1
: **** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:

: (concat (org-sbe STARS) (org-sbe KEYWORD) (org-sbe PRIORITY) (org-sbe TITLE) (org-sbe TAGS))

#+BEGIN_SRC js :cmd "node" :var data=(org-sbe headline-test1) :results replace output :var pattern=headline-regex-js-elisp() :wrap "SRC js :eval never"
  console.log(JSON.stringify(pattern))
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
"^([*]+(?=\\s))(( +)(TODO|DONE))?(( +)(\\[#[a-zA-Z]\\]))?(( +)(.+))?(( +)(([:\\w@#%]+))+)?"
/^([*]+(?=\s))(( +)(TODO|DONE))?(( +)(\[#[a-zA-Z]\]))?(( +)(.+))?(( +)(([:\w@#%]+))+)?/
[ '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  '****',
  ' DONE',
  ' ',
  'DONE',
  ' [#A]',
  ' ',
  '[#A]',
  ' *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  ' ',
  '*this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  undefined,
  undefined,
  undefined,
  undefined,
  index: 0,
  input: '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:' ]
#+END_SRC

******* STARS

#+NAME: STARS
#+BEGIN_SRC css
  ^([*]+(?=\s))
#+END_SRC

#+CALL: elisp/display-this-here(data=org-syntax-stars-definition)

#+RESULTS:
:   STARS is a string starting at column 0, containing at least one
:   asterisk (and up to ~org-inlinetask-min-level~ if =org-inlinetask=
:   library is loaded) and ended by a space character.  The number of
:   asterisks is used to define the level of the headline.  It's the
:   sole compulsory part of a headline.

#+BEGIN_SRC js :cmd "node" :var data=(org-sbe headline-test1) :results replace output :var pattern=(org-sbe STARS) :wrap "SRC js :eval never" :exports results 
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/^([*]+(?=\s))/
[ '****',
  '****',
  index: 0,
  input: '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:' ]
#+END_SRC

******** Notes

*Note:* ~${1:/length}.~ is *not* working

#+BEGIN_EXAMPLE

  'headlines':
    'patterns': [
      {
        'begin': '^([*]+(?=\\s))'
        'end': '$'
        'captures':
          '1':
            'name': 'punctuation.definition.string.org-mode'
        'name': 'markup.heading.heading-${1:/length}.org-mode'
      }
    ]

#+END_EXAMPLE

******* KEYWORD

#+NAME: KEYWORD
#+BEGIN_SRC css
  (( +)(TODO|DONE))
#+END_SRC

#+CALL: elisp/display-this-here(data=org-syntax-keyword-definition)

#+RESULTS:
:   KEYWORD is a TODO keyword, which has to belong to the list defined
:   in ~org-todo-keywords-1~.  Case is significant.

#+BEGIN_SRC js :cmd "node" :var data=(org-sbe headline-test1) :results replace output :var pattern=(concat (org-sbe STARS) (org-sbe KEYWORD)) :wrap "SRC js :eval never" :exports results 
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/^([*]+(?=\s))(( +)(TODO|DONE))/
[ '**** DONE',
  '****',
  ' DONE',
  ' ',
  'DONE',
  index: 0,
  input: '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:' ]
#+END_SRC

******* PRIORITY

#+NAME: PRIORITY
#+BEGIN_SRC css
  (( +)(\[#[a-zA-Z]\]))
#+END_SRC

#+CALL: elisp/display-this-here(data=org-syntax-priority-definition) :results drawer :exports results

#+RESULTS:
:   PRIORITY is a priority cookie, i.e. a single letter preceded by
:   a hash sign # and enclosed within square brackets.

#+BEGIN_SRC js :cmd "node" :var data=(org-sbe headline-test1) :results replace output :var pattern=(concat (org-sbe STARS) (org-sbe KEYWORD) (org-sbe PRIORITY)) :wrap "SRC js :eval never" :exports results 
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/^([*]+(?=\s))(( +)(TODO|DONE))(( +)(\[#[a-zA-Z]\]))/
[ '**** DONE [#A]',
  '****',
  ' DONE',
  ' ',
  'DONE',
  ' [#A]',
  ' ',
  '[#A]',
  index: 0,
  input: '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:' ]
#+END_SRC

******* TITLE [0/2]

#+NAME: TITLE
#+BEGIN_SRC css 
  (( +)(.+))
#+END_SRC

#+RESULTS: TITLE
: (( +)(.+))

#+CALL: elisp/display-this-here(data=org-syntax-title-definition)

#+RESULTS:
:   TITLE can be made of any character but a new line.  Though, it will
:   match after every other part have been matched.

#+BEGIN_SRC js :cmd "node" :var data=(org-sbe headline-test1) :results replace output :var pattern=(concat (org-sbe STARS) (org-sbe KEYWORD) (org-sbe PRIORITY) (org-sbe TITLE) ) :wrap "SRC js :eval never" :exports results 
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/^([*]+(?=\s))(( +)(TODO|DONE))(( +)(\[#[a-zA-Z]\]))(( +)(.+))/
[ '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  '****',
  ' DONE',
  ' ',
  'DONE',
  ' [#A]',
  ' ',
  '[#A]',
  ' *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  ' ',
  '*this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  index: 0,
  input: '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:' ]
#+END_SRC

- [ ] Add TITLE begins with =COMMENT= to regular expression

  #+CALL: elisp/display-this-here(data=org-syntax-title-comment-definition)

  #+RESULTS:
  :   If the first word appearing in the title is "COMMENT", the headline
  :   will be considered as "commented".  Case is significant.

- [ ] Add TITLE is =Footnotes= to regular expression

  #+CALL: elisp/display-this-here(data=org-syntax-title-footnote-section-definition)

  #+RESULTS:
  :   If its title is ~org-footnote-section~, it will be considered as
  :   a "footnote section".  Case is significant.

******* TAGS [0/2]

#+NAME: TAGS
#+BEGIN_SRC css
  (( +)(([:\w@#%]+))+)
#+END_SRC

#+CALL: elisp/display-this-here(data=org-syntax-tags-definition)

#+RESULTS:
:   TAGS is made of words containing any alpha-numeric character,
:   underscore, at sign, hash sign or percent sign, and separated with
:   colons.

: ( +(([:\\w@#%]+))+))?
: orig "^(?:[*]+) (?:TODO|DONE)? (?:\\[#[a-zA-Z]\\])? (?:.+)? (([:\\w@#%]+))+"
: (concat (org-sbe STARS) (org-sbe KEYWORD) (org-sbe PRIORITY) (org-sbe TITLE) (org-sbe TAGS))

#+BEGIN_SRC js :cmd "node" :var data=(org-sbe headline-test1) :results replace output :var pattern=(concat (org-sbe STARS) (org-sbe KEYWORD) (org-sbe PRIORITY) (org-sbe TITLE) (org-sbe TAGS)) :wrap "SRC js :eval never" :exports results 
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/^([*]+(?=\s))(( +)(TODO|DONE))(( +)(\[#[a-zA-Z]\]))(( +)(.+))(( +)(([:\w@#%]+))+)/
[ '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:',
  '****',
  ' DONE',
  ' ',
  'DONE',
  ' [#A]',
  ' ',
  '[#A]',
  ' *this* /is/ _the_ =title= +of+ ~my~ headline :notattag:',
  ' ',
  '*this* /is/ _the_ =title= +of+ ~my~ headline :notattag:',
  ' :tag1:@tag2:#tag3:%TAG4#:',
  ' ',
  ':tag1:@tag2:#tag3:%TAG4#:',
  ':tag1:@tag2:#tag3:%TAG4#:',
  index: 0,
  input: '**** DONE [#A] *this* /is/ _the_ =title= +of+ ~my~ headline :notattag: :tag1:@tag2:#tag3:%TAG4#:' ]
#+END_SRC

- [ ] Add =[:]ARCHIVE[:]= tag to regular expression 
  
  #+CALL: elisp/display-this-here(data=org-syntax-tags-archive-definition)

  #+RESULTS:
  :   If "ARCHIVE" is one of its tags, it will be considered as
  :   "archived".  Case is significant.

- [ ] Fix empty tag match, i.e. =::=, in regular expression

*** Affiliated Keywords
  :PROPERTIES:
  :CUSTOM_ID: Affiliated_keywords
  :END:

  With the exception of inlinetasks, items, planning, clocks, node
  properties and table rows, every other element type can be assigned
  attributes.

  This is done by adding specific keywords, named "affiliated
  keywords", just above the element considered, no blank line
  allowed.

  Affiliated keywords are built upon one of the following patterns:
  "#+KEY: VALUE", "#+KEY[OPTIONAL]: VALUE" or "#+ATTR_BACKEND: VALUE".

  KEY is either "CAPTION", "HEADER", "NAME", "PLOT" or "RESULTS"
  string.

  BACKEND is a string constituted of alpha-numeric characters, hyphens
  or underscores.

  OPTIONAL and VALUE can contain any character but a new line.  Only
  "CAPTION" and "RESULTS" keywords can have an optional value.

  An affiliated keyword can appear more than once if KEY is either
  "CAPTION" or "HEADER" or if its pattern is "#+ATTR_BACKEND: VALUE".

  "CAPTION", "AUTHOR", "DATE" and "TITLE" keywords can contain objects
  in their value and their optional value, if applicable.

**** Code  

***** Regular Expressions

*** Greater Elements
  :PROPERTIES:
  :CUSTOM_ID: Greater_Elements
  :END:

  Unless specified otherwise, greater elements can contain directly
  any other element or greater element excepted:

  - elements of their own type,
  - node properties, which can only be found in property drawers,
  - items, which can only be found in plain lists.

**** Greater Blocks
   :PROPERTIES:
   :CUSTOM_ID: Greater_Blocks
   :END:

   Greater blocks consist in the following pattern:

   #+BEGIN_EXAMPLE
   ,#+BEGIN_NAME PARAMETERS
   CONTENTS
   ,#+END_NAME
   #+END_EXAMPLE

   NAME can contain any non-whitespace character.

   PARAMETERS can contain any character other than new line, and can
   be omitted.

   If NAME is "CENTER", it will be a "center block".  If it is
   "QUOTE", it will be a "quote block".

   If the block is neither a center block, a quote block or a block
   element, it will be a "special block".

   CONTENTS can contain any element, except : a line =#+END_NAME= on
   its own.  Also lines beginning with STARS must be quoted by
   a comma.

***** Code  

****** Regular Expressions

******* Greater Blocks

#+NAME: greater-elements-greater-blocks-names
| Greater-Element-Greater-Block-Name |
|------------------------------------|
| CENTER                             |
| QUOTE                              |

******* Dynamic Blocks

******* Special Blocks

**** Drawers and Property Drawers
   :PROPERTIES:
   :CUSTOM_ID: Drawers
   :END:

   Pattern for drawers is:

   #+BEGIN_EXAMPLE
   :NAME:
   CONTENTS
   :END:
   #+END_EXAMPLE

   NAME can contain word-constituent characters, hyphens and
   underscores.

   CONTENTS can contain any element but another drawer.

***** Code  

****** Regular Expressions

**** Dynamic Blocks
   :PROPERTIES:
   :CUSTOM_ID: Dynamic_Blocks
   :END:

   Pattern for dynamic blocks is:

   #+BEGIN_EXAMPLE
   ,#+BEGIN: NAME PARAMETERS
   CONTENTS
   ,#+END:
   #+END_EXAMPLE

   NAME cannot contain any whitespace character.

   PARAMETERS can contain any character and can be omitted.

***** Code  

****** Regular Expressions

**** Footnote Definitions
   :PROPERTIES:
   :CUSTOM_ID: Footnote_Definitions
   :END:

   Pattern for footnote definitions is:

   #+BEGIN_EXAMPLE
   [fn:LABEL] CONTENTS
   #+END_EXAMPLE

   It must start at column 0.

   LABEL is either a number or follows the pattern "fn:WORD", where
   word can contain any word-constituent character, hyphens and
   underscore characters.

   CONTENTS can contain any element excepted another footnote
   definition.  It ends at the next footnote definition, the next
   headline, two consecutive empty lines or the end of buffer.

***** Code  

****** Regular Expressions

**** Inlinetasks
   :PROPERTIES:
   :CUSTOM_ID: Inlinetasks
   :END:

   Inlinetasks are defined by ~org-inlinetask-min-level~ contiguous
   asterisk characters starting at column 0, followed by a whitespace
   character.

   Optionally, inlinetasks can be ended with a string constituted of
   ~org-inlinetask-min-level~ contiguous asterisk characters starting
   at column 0, followed by a space and the "END" string.

   Inlinetasks are recognized only after =org-inlinetask= library is
   loaded.

***** Code  

****** Regular Expressions

**** Plain Lists and Items
   :PROPERTIES:
   :CUSTOM_ID: Plain_Lists_and_Items
   :END:

   Items are defined by a line starting with the following pattern:
   "BULLET COUNTER-SET CHECK-BOX TAG", in which only BULLET is
   mandatory.

   BULLET is either an asterisk, a hyphen, a plus sign character or
   follows either the pattern "COUNTER." or "COUNTER)".  In any case,
   BULLET is follwed by a whitespace character or line ending.

   COUNTER can be a number or a single letter.

   COUNTER-SET follows the pattern [@COUNTER].

   CHECK-BOX is either a single whitespace character, a "X" character
   or a hyphen, enclosed within square brackets.

   TAG follows "TAG-TEXT ::" pattern, where TAG-TEXT can contain any
   character but a new line.

   An item ends before the next item, the first line less or equally
   indented than its starting line, or two consecutive empty lines.
   Indentation of lines within other greater elements do not count,
   neither do inlinetasks boundaries.

   A plain list is a set of consecutive items of the same indentation.
   It can only directly contain items.

   If first item in a plain list has a counter in its bullet, the
   plain list will be an "ordered plain-list".  If it contains a tag,
   it will be a "descriptive list".  Otherwise, it will be an
   "unordered list".  List types are mutually exclusive.

   For example, consider the following excerpt of an Org document:

   #+BEGIN_EXAMPLE
   1. item 1
   2. [X] item 2
      - some tag :: item 2.1
   #+END_EXAMPLE

   Its internal structure is as follows:

   #+BEGIN_EXAMPLE
   (ordered-plain-list
    (item)
    (item
     (descriptive-plain-list
      (item))))
   #+END_EXAMPLE

***** Code

****** Regular Expressions

******* Unordered Lists

: ^( +[*]| *[+-])( +)(([\[])([ X-])([\]])( +))?((.*)\s(.*))?$

******* Ordered Lists

: ^( *\d+[.])( +)(([\[])([ X-])([\]])( )+)?((.*)\s(.*))?$
**** Property Drawers
   :PROPERTIES:
   :CUSTOM_ID: Property_Drawers
   :END:

   Property drawers are a special type of drawer containing properties
   attached to a headline.  They are located right after a headline
   and its planning information.

   #+BEGIN_EXAMPLE
   HEADLINE
   PROPERTYDRAWER

   HEADLINE
   PLANNING
   PROPERTYDRAWER
   #+END_EXAMPLE

   PROPERTYDRAWER follows the pattern

   #+BEGIN_EXAMPLE
   :PROPERTIES:
   CONTENTS
   :END:
   #+END_EXAMPLE

   where CONTENTS consists of zero or more node properties.

***** Code  

****** Regular Expressions

**** Tables
   :PROPERTIES:
   :CUSTOM_ID: Tables
   :END:

   Tables start at lines beginning with either a vertical bar or the
   "+-" string followed by plus or minus signs only, assuming they are
   not preceded with lines of the same type.  These lines can be
   indented.

   A table starting with a vertical bar has "org" type.  Otherwise it
   has "table.el" type.

   Org tables end at the first line not starting with a vertical bar.
   Table.el tables end at the first line not starting with either
   a vertical line or a plus sign.  Such lines can be indented.

   An org table can only contain table rows.  A table.el table does
   not contain anything.

   One or more "#+TBLFM: FORMULAS" lines, where "FORMULAS" can contain
   any character, can follow an org table.

***** Code  

****** Regular Expressions

*** Elements
  :PROPERTIES:
  :CUSTOM_ID: Elements
  :END:

  Elements cannot contain any other element.

  Only keywords whose name belongs to
  ~org-element-document-properties~, verse blocks , paragraphs and
  table rows can contain objects.

**** Babel Call
   :PROPERTIES:
   :CUSTOM_ID: Babel_Call
   :END:

   Pattern for babel calls is:

   #+BEGIN_EXAMPLE
   ,#+CALL: VALUE
   #+END_EXAMPLE

   VALUE is optional.  It can contain any character but a new line.

***** Code  

****** Regular Expressions

**** Blocks
   :PROPERTIES:
   :CUSTOM_ID: Blocks
   :END:

   Like greater blocks, pattern for blocks is:

   #+BEGIN_EXAMPLE
   ,#+BEGIN_NAME DATA
   CONTENTS
   ,#+END_NAME
   #+END_EXAMPLE

   NAME cannot contain any whitespace character.

   If NAME is "COMMENT", it will be a "comment block".  If it is
   "EXAMPLE", it will be an "example block".  If it is "EXPORT", it
   will be an "export block".  If it is "SRC", it will be a "source
   block".  If it is "VERSE", it will be a "verse block".

   DATA can contain any character but a new line.  It can be ommitted,
   unless the block is either a "source block" or an "export block".

   In the latter case, it should be constituted of a single word.

   In the former case, it must follow the pattern "LANGUAGE SWITCHES
   ARGUMENTS", where SWITCHES and ARGUMENTS are optional.

   LANGUAGE cannot contain any whitespace character.

   SWITCHES is made of any number of "SWITCH" patterns, separated by
   blank lines.

   A SWITCH pattern is either "-l "FORMAT"", where FORMAT can contain
   any character but a double quote and a new line, "-S" or "+S",
   where S stands for a single letter.

   ARGUMENTS can contain any character but a new line.

   CONTENTS can contain any character, including new lines.  Though it
   will only contain Org objects if the block is a verse block.
   Otherwise, CONTENTS will not be parsed.

***** Code  

****** Regular Expressions

******* Blocks

#+NAME: elements-blocks-names
| Element-Block-Name | Default-Export-Backend | Atom-Scope-Name |
|--------------------+------------------------+-----------------|
| ASCII              | True                   | text.plain      |
| BEAMER             | True                   | text.tex.latex  |
| COMMENT            | False                  |                 |
| EXAMPLE            | False                  |                 |
| HTML               | True                   | text.html.basic |
| LATEX              | True                   | text.tex.latex  |
| MAN                | True                   | text.roff       |
| MD                 | True                   | source.gfm      |
| ODT                | True                   | text.xml        |
| ORG                | True                   |                 |
| TEXINFO            | True                   | source.texi     |
| VERSE              | False                  |                 |

******* Source Blocks

******* Export Blocks

******** Code

#+BEGIN_SRC ruby :var export_block_type="HTML" :var atom_scope_name="TEXT.HTML.BASIC"
  export_block_template = <<-EOT
    'export-block-#{export_block_type.downcase}':
      'patterns':[
          {
            'begin': '^(?i)( *#[+]BEGIN_EXPORT +)(#{export_block_type.downcase})$'
            'beginCaptures':
              '1':
                'name': 'punctuation.definition.string.org-mode'
              '2':
                'name': 'export-block.type.org-mode'
            'end': '^(?i)( *#[+]END_EXPORT)$'
            'endCaptures':
              '0':
                'name': 'punctuation.definition.string.org-mode'
            'contentName': 'source.embedded.#{export_block_type.downcase}-org-mode'
            'patterns':[
              {
                'include': '#{atom_scope_name.downcase}'
              }
            ]
          }
      ]
  EOT
#+END_SRC

#+RESULTS:
#+begin_example
  'export-block-html':
    'patterns':[
        {
          'begin': '^(?i)( *#[+]BEGIN_EXPORT +)(html)$'
          'beginCaptures':
            '1':
              'name': 'punctuation.definition.string.org-mode'
            '2':
              'name': 'export-block.type.org-mode'
          'end': '^(?i)( *#[+]END_EXPORT)$'
          'endCaptures':
            '0':
              'name': 'punctuation.definition.string.org-mode'
          'contentName': 'source.embedded.html-org-mode'
          'patterns':[
            {
              'include': 'text.html.basic'
            }
          ]
        }
    ]
#+end_example

**** Clock, Diary Sexp and Planning
   :PROPERTIES:
   :CUSTOM_ID: Clock,_Diary_Sexp_and_Planning
   :END:

   A clock follows the pattern:
   
   #+BEGIN_EXAMPLE
   CLOCK: TIMESTAMP DURATION
   #+END_EXAMPLE

   Both TIMESTAMP and DURATION are optional.

   TIMESTAMP is a timestamp object.

   DURATION follows the pattern:

   #+BEGIN_EXAMPLE
   => HH:MM
   #+END_EXAMPLE

   HH is a number containing any number of digits.  MM is a two digit
   numbers.

   A diary sexp is a line starting at column 0 with "%%(" string.  It
   can then contain any character besides a new line.

   A planning is an element with the following pattern:

   #+BEGIN_EXAMPLE
   HEADLINE
   PLANNING
   #+END_EXAMPLE

   where HEADLINE is a headline element and PLANNING is a line filled
   with INFO parts, where each of them follows the pattern:

   #+BEGIN_EXAMPLE
   KEYWORD: TIMESTAMP
   #+END_EXAMPLE

   KEYWORD is either "DEADLINE", "SCHEDULED" or "CLOSED".  TIMESTAMP
   is a timestamp object.

   In particular, no blank line is allowed between PLANNING and
   HEADLINE.

***** Code  

****** Regular Expressions

**** Comments
   :PROPERTIES:
   :CUSTOM_ID: Comments
   :END:

   A "comment line" starts with a hash signe and a whitespace
   character or an end of line.

   Comments can contain any number of consecutive comment lines.

***** Code  

****** Regular Expressions

**** Fixed Width Areas
   :PROPERTIES:
   :CUSTOM_ID: Fixed_Width_Areas
   :END:

   A "fixed-width line" start with a colon character and a whitespace
   or an end of line.

   Fixed width areas can contain any number of consecutive fixed-width
   lines.

***** Code  

****** Regular Expressions

**** Horizontal Rules
   :PROPERTIES:
   :CUSTOM_ID: Horizontal_Rules
   :END:

   A horizontal rule is a line made of at least 5 consecutive hyphens.
   It can be indented.

***** Code  

****** Regular Expressions

**** Keywords
   :PROPERTIES:
   :CUSTOM_ID: Keywords
   :END:

   Keywords follow the syntax:

   #+BEGIN_EXAMPLE
   ,#+KEY: VALUE
   #+END_EXAMPLE

   KEY can contain any non-whitespace character, but it cannot be
   equal to "CALL" or any affiliated keyword.

   VALUE can contain any character excepted a new line.

   If KEY belongs to ~org-element-document-properties~, VALUE can
   contain objects.

***** Code  

****** Regular Expressions

**** LaTeX Environments
   :PROPERTIES:
   :CUSTOM_ID: LaTeX_Environments
   :END:

   Pattern for LaTeX environments is:

   #+BEGIN_EXAMPLE
   \begin{NAME} CONTENTS \end{NAME}
   #+END_EXAMPLE

   NAME is constituted of alpha-numeric or asterisk characters.

   CONTENTS can contain anything but the "\end{NAME}" string.

***** Code  

****** Regular Expressions

**** Node Properties
   :PROPERTIES:
   :CUSTOM_ID: Node_Properties
   :END:

   Node properties can only exist in property drawers.  Their pattern
   is any of the following

   #+BEGIN_EXAMPLE
   :NAME: VALUE

   :NAME+: VALUE

   :NAME:

   :NAME+:
   #+END_EXAMPLE

   NAME can contain any non-whitespace character but cannot end with
   a plus sign.  It cannot be the empty string.

   VALUE can contain anything but a newline character.

***** Code  

****** Regular Expressions

**** Paragraphs
   :PROPERTIES:
   :CUSTOM_ID: Paragraphs
   :END:

   Paragraphs are the default element, which means that any
   unrecognized context is a paragraph.

   Empty lines and other elements end paragraphs.

   Paragraphs can contain every type of object.

***** Code  

****** Regular Expressions

**** Table Rows
   :PROPERTIES:
   :CUSTOM_ID: Table_Rows
   :END:

   A table rows is either constituted of a vertical bar and any number
   of table cells or a vertical bar followed by a hyphen.

   In the first case the table row has the "standard" type.  In the
   second case, it has the "rule" type.

   Table rows can only exist in tables.

***** Code  

****** Regular Expressions

*** Objects
  :PROPERTIES:
  :CUSTOM_ID: Objects
  :END:

  Objects can only be found in the following locations:

  - affiliated keywords defined in ~org-element-parsed-keywords~,
  - document properties,
  - headline titles,
  - inlinetask titles,
  - item tags,
  - paragraphs,
  - table cells,
  - table rows, which can only contain table cell
    objects,
  - verse blocks.
    
  Most objects cannot contain objects.  Those which can will be
  specified.

**** Entities and LaTeX Fragments
   :PROPERTIES:
   :CUSTOM_ID: Entities_and_LaTeX_Fragments
   :END:

   An entity follows the pattern:

   #+BEGIN_EXAMPLE
   \NAME POST
   #+END_EXAMPLE

   where NAME has a valid association in either ~org-entities~ or
   ~org-entities-user~.

   POST is the end of line, "{}" string, or a non-alphabetical
   character.  It isn't separated from NAME by a whitespace character.

   A LaTeX fragment can follow multiple patterns:

   #+BEGIN_EXAMPLE
   \NAME BRACKETS
   \(CONTENTS\)
   \[CONTENTS\]
   $$CONTENTS$$
   PRE$CHAR$POST
   PRE$BORDER1 BODY BORDER2$POST
   #+END_EXAMPLE

   NAME contains alphabetical characters only and must not have an
   association in either ~org-entities~ or ~org-entities-user~.

   BRACKETS is optional, and is not separated from NAME with white
   spaces.  It may contain any number of the following patterns:

   #+BEGIN_EXAMPLE
   [CONTENTS1]
   {CONTENTS2}
   #+END_EXAMPLE

   where CONTENTS1 can contain any characters excepted "{" "}", "["
   "]" and newline and CONTENTS2 can contain any character excepted
   "{", "}" and newline.

   CONTENTS can contain any character but cannot contain "\)" in the
   second template or "\]" in the third one.

   PRE is either the beginning of line or a character different from
   ~$~.

   CHAR is a non-whitespace character different from ~.~, ~,~, ~?~,
   ~;~, ~'~ or a double quote.

   POST is any punctuation (including parentheses and quotes) or space
   character, or the end of line.

   BORDER1 is a non-whitespace character different from ~.~, ~,~, ~;~
   and ~$~.

   BODY can contain any character excepted ~$~, and may not span over
   more than 3 lines.

   BORDER2 is any non-whitespace character different from ~,~, ~.~ and
   ~$~.

   #+ATTR_ASCII: :width 5
   -----

   #+BEGIN_QUOTE
   It would introduce incompatibilities with previous Org versions,
   but support for ~$...$~ (and for symmetry, ~$$...$$~) constructs
   ought to be removed.

   They are slow to parse, fragile, redundant and imply false
   positives.  --- ngz
   #+END_QUOTE

***** Code  

****** Regular Expressions

**** Export Snippets
   :PROPERTIES:
   :CUSTOM_ID: Export_Snippets
   :END:

   Patter for export snippets is:

   #+BEGIN_EXAMPLE
   @@NAME:VALUE@@
   #+END_EXAMPLE

   NAME can contain any alpha-numeric character and hyphens.

   VALUE can contain anything but "@@" string.

***** Code  

****** Regular Expressions

**** Footnote References
   :PROPERTIES:
   :CUSTOM_ID: Footnote_References
   :END:

   There are four patterns for footnote references:

   #+BEGIN_EXAMPLE
   [fn:LABEL]
   [fn:LABEL:DEFINITION]
   [fn::DEFINITION]
   #+END_EXAMPLE

   LABEL can contain any word constituent character, hyphens and
   underscores.

   DEFINITION can contain any character.  Though opening and closing
   square brackets must be balanced in it.  It can contain any object
   encountered in a paragraph, even other footnote references.

   If the reference follows the second pattern, it is called an
   "inline footnote".  If it follows the third one, i.e. if LABEL is
   omitted, it is an "anonymous footnote".

***** Code  

****** Regular Expressions

**** Inline Babel Calls and Source Blocks
   :PROPERTIES:
   :CUSTOM_ID: Inline_Babel_Calls_and_Source_Blocks
   :END:

   Inline Babel calls follow any of the following patterns:

   #+BEGIN_EXAMPLE
   call_NAME(ARGUMENTS)
   call_NAME[HEADER](ARGUMENTS)[HEADER]
   #+END_EXAMPLE

   NAME can contain any character besides ~(~, ~)~ and "\n".

   HEADER can contain any character besides ~]~ and "\n".

   ARGUMENTS can contain any character besides ~)~ and "\n".

   Inline source blocks follow any of the following patterns:
   
   #+BEGIN_EXAMPLE
   src_LANG{BODY}
   src_LANG[OPTIONS]{BODY}
   #+END_EXAMPLE

   LANG can contain any non-whitespace character.

   OPTIONS and BODY can contain any character but "\n".

***** Code  

****** Regular Expressions

**** Line Breaks
   :PROPERTIES:
   :CUSTOM_ID: Line_Breaks
   :END:

   A line break consists in "\\SPACE" pattern at the end of an
   otherwise non-empty line.

   SPACE can contain any number of tabs and spaces, including 0.

***** Code  

****** Regular Expressions

**** Links
   :PROPERTIES:
   :CUSTOM_ID: Links
   :END:

   There are 4 major types of links:

   #+BEGIN_EXAMPLE
   PRE1 RADIO POST1          ("radio" link)
   <PROTOCOL:PATH>           ("angle" link)
   PRE2 PROTOCOL:PATH2 POST2 ("plain" link)
   [[PATH3]DESCRIPTION]      ("regular" link)
   #+END_EXAMPLE

   PRE1 and POST1, when they exist, are non alphanumeric characters.

   RADIO is a string matched by some radio target.  It may contain
   entities, latex fragments, subscript and superscript.

   PROTOCOL is a string among ~org-link-types~.

   PATH can contain any character but ~]~, ~<~, ~>~ and ~\n~.

   PRE2 and POST2, when they exist, are non word constituent
   characters.

   PATH2 can contain any non-whitespace character excepted ~(~, ~)~,
   ~<~ and ~>~.  It must end with a word-constituent character, or any
   non-whitespace non-punctuation character followed by ~/~.

   DESCRIPTION must be enclosed within square brackets.  It can
   contain any character but square brackets.  It can contain any
   object found in a paragraph excepted a footnote reference, a radio
   target and a line break.  It cannot contain another link either,
   unless it is a plain or angular link.

   DESCRIPTION is optional.

   PATH3 is built according to the following patterns:

   #+BEGIN_EXAMPLE
   FILENAME           ("file" type)
   PROTOCOL:PATH4     ("PROTOCOL" type)
   PROTOCOL://PATH4   ("PROTOCOL" type)
   id:ID              ("id" type)
   #CUSTOM-ID         ("custom-id" type)
   (CODEREF)          ("coderef" type)
   FUZZY              ("fuzzy" type)
   #+END_EXAMPLE

   FILENAME is a file name, either absolute or relative.

   PATH4 can contain any character besides square brackets.

   ID is constituted of hexadecimal numbers separated with hyphens.

   PATH4, CUSTOM-ID, CODEREF and FUZZY can contain any character
   besides square brackets.

***** Code  

****** Regular Expressions

******* Radio Links

#+NAME: radio-links-js
#+BEGIN_SRC css :noweb yes
  <<PRE1>><<RADIO>><<POST1>>
#+END_SRC

#+RESULTS: radio-links-js
: (<<<)([\w \t :;'"|\\~`!@#$%^&*(){}\[\]=\-_+|.,?/]+)(>>>)

******** PRE1

#+NAME: PRE1
#+BEGIN_SRC css
  (<<<)
#+END_SRC

******** POST1

#+NAME: POST1
#+BEGIN_SRC css
  (>>>)
#+END_SRC

******** RADIO

#+NAME: RADIO
#+BEGIN_SRC css
  ([\w \t :;'"|\\~`!@#$%^&*(){}\[\]=\-_+|.,?/]+)
#+END_SRC

******** Grammar

#+NAME: gen-grammar-radio-links-cson
#+BEGIN_SRC ruby :var object_link_type="radio-link" :var object_link_pattern=radio-links-js 
  object_link_template = <<-EOT
    'object-#{object_link_type.downcase}':
      'patterns':[
          {
            'match': #{object_link_pattern.inspect()}
            'captures':
              '0':
                'name': 'markup.underline.link.org-mode'
              '1':
                'name': 'punctuation.definition.radio-link.begin.org-mode'
              '2':
                'name': 'markup.radio-link.org-mode'
              '3':
                'name': 'punctuation.definition.radio-link.end.org-mode'
          }
      ]
  EOT
#+END_SRC

#+NAME: grammar-radio-links-cson
#+RESULTS: gen-grammar-radio-links-cson
#+begin_example
  'object-radio-link':
    'patterns':[
        {
          'match': "(<<<)([\\w \\t :;'\"|\\\\~`!@\#$%^&*(){}\\[\\]=\\-_+|.,?/]+)(>>>)"
          'captures':
            '0':
              'name': 'markup.underline.link.org-mode'
            '1':
              'name': 'punctuation.definition.radio-link.begin.org-mode'
            '2':
              'name': 'markup.radio-link.org-mode'
            '3':
              'name': 'punctuation.definition.radio-link.end.org-mode'
        }
    ]
#+end_example

******* Angle, Plain and Regular Links

******** PROTOCOL

#+NAME: describe-variable/org-link-types-re
#+BEGIN_SRC elisp :exports none 
 (describe-variable 'org-link-types-re)
#+END_SRC

#+RESULTS:
: org-link-types-re is a variable defined in ‘org.el’.
: Its value is
: "\\`\\(b\\(?:bdb\\|ibtex\\)\\|do\\(?:cview\\|i\\)\\|e\\(?:lisp\\|shell\\|ww\\)\\|f\\(?:ile\\(?:\\+\\(?:\\(?:emac\\|sy\\)s\\)\\)?\\|tp\\)\\|gnus\\|h\\(?:elp\\|ttps?\\)\\|i\\(?:d\\|nfo\\|rc\\)\\|m\\(?:ailto\\|he\\)\\|news\\|rmail\\|shell\\|w3m\\):"
: 
: Documentation:
: Matches a link that has a url-like prefix like "http:"

# \b(b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):

#+NAME: PROTOCOL
#+BEGIN_SRC css
  (((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}/)
#+END_SRC

********* Implementation notes about ~PROTOCOL~

  - Added capture group around ~PROTOCOL~ regex.

  - Updates to allow expression to match most[fn:11] the [[file:atom-org-mode-package.org::*External Link Patterns][External Link Patterns]].
    - ~\\`~ \rightarrow removed 
    - ~\\+~ \rightarrow ~[+]~
    - ~\\(~ \rightarrow ~(~
    - ~\\)~ \rightarrow ~)~
    - ~\\|~ \rightarrow ~|~
    - ~PROTOCOL~ \rightarrow ~(PROTOCOL|[.]{0,2}/)~ to allow matching plain links without ~PROTOCOL~ to imitate observed behavior in emacs.
  
********* External Link Patterns [fn:12]

http://www.astro.uva.nl/~dominik             on the web
doi:10.1000/182                              DOI for an electronic resource
file:/home/dominik/images/jupiter.jpg        file, absolute path
/home/dominik/images/jupiter.jpg             same as above
file:papers/last.pdf                         file, relative path
./papers/last.pdf                            same as above
file:/ssh:myself@some.where:papers/last.pdf  file, path on remote machine
/ssh:myself@some.where:papers/last.pdf       same as above
file:sometextfile::NNN                       file, jump to line number
file:projects.org                            another Org file
file:projects.org::some words                text search in Org file(31)
file:projects.org::*task title               heading search in Org file(32)
docview:papers/last.pdf::NNN                 open in doc-view mode at page
id:B7423F4D-2E8A-471B-8810-C40F074717E9      Link to heading by ID
news:comp.emacs                              Usenet link
mailto:adent@galaxy.net                      Mail link
mhe:folder                                   MH-E folder link
mhe:folder#id                                MH-E message link
rmail:folder                                 RMAIL folder link
rmail:folder#id                              RMAIL message link
gnus:group                                   Gnus group link
gnus:group#id                                Gnus article link
bbdb:R.*Stallman                             BBDB link (with regexp)
irc:/irc.com/#emacs/bob                      IRC link
info:org#External links                      Info node or index link
shell:ls *.org                               A shell command
elisp:org-agenda                             Interactive Elisp command
elisp:(find-file-other-frame "Elisp.org")    Elisp form to evaluate

******** Angle Links

# Are these angle links https://orgmode.org/manual/Internal-links.html ? probably.
# - one item
# - <<target>>another item
# Here we refer to item [[target]].
# 
#

#+NAME: angle-links-js
#+BEGIN_SRC css :noweb yes 
  ([<]{2})<<PROTOCOL>>?<<PATH>>([>]{2})
#+END_SRC

#+RESULTS: angle-links-js
: ([<]{2})(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}/)?([^\]<>\n]+)([>]{2})

********* PATH

: PATH can contain any character but ~]~, ~<~, ~>~ and ~\n~.

#+NAME: PATH
#+BEGIN_SRC css
  ([^\]<>\n]+)
#+END_SRC

********* Grammar

#+NAME: gen-grammar-angle-links-cson
#+BEGIN_SRC ruby :var object_link_type="angle-link" :var object_link_pattern=angle-links-js 
  object_link_template = <<-EOT
    'object-#{object_link_type.downcase}':
      'patterns':[
          {
            'match': #{object_link_pattern.inspect()}
            'captures':
              '0':
                'name': 'markup.underline.link.org-mode'
              '1':
                'name': 'punctuation.definition.angle-link.begin.org-mode'
              '5':
                'name': 'markup.angle-link.org-mode'
              '6':
                'name': 'punctuation.definition.angle-link.end.org-mode'
          }
      ]
  EOT
#+END_SRC

#+NAME: grammar-angle-links-cson
#+RESULTS: gen-grammar-angle-links-cson
#+begin_example
  'object-angle-link':
    'patterns':[
        {
          'match': "([<]{2})(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}/)?([^\\]<>\\n]+)([>]{2})"
          'captures':
            '0':
              'name': 'markup.underline.link.org-mode'
            '1':
              'name': 'punctuation.definition.angle-link.begin.org-mode'
            '5':
              'name': 'markup.angle-link.org-mode'
            '6':
              'name': 'punctuation.definition.angle-link.end.org-mode'
        }
    ]
#+end_example

********* Implementation Notes about Angle Link

- ~PROTOCOL~ \rightarrow ~PROTOCOL?~

********* Tests - Angle Link

# - <<target>> another item

#+BEGIN_SRC js :cmd "node" :var data="- <<target>>another item" :results replace output :var pattern=angle-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([<]{2})(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)?([^\]<>\n]+)([>]{2})/
[ '<<target>>',
  '<<',
  undefined,
  undefined,
  undefined,
  'target',
  '>>',
  index: 2,
  input: '- <<target>>another item' ]
#+END_SRC

******** <<<Plain Links>>>

#+BEGIN_COMMENT
   # Best # ([^\w\S]+)((\b(b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]?/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&/]/)))(\W)

   # PRE2 PROTOCOL:PATH2 POST2 ("plain" link)

   PRE2 and POST2, when they exist, are non word constituent
   characters.

   PATH2 can contain any non-whitespace character excepted ~(~, ~)~,
   ~<~ and ~>~.  It must end with a word-constituent character, or any
   non-whitespace non-punctuation character followed by ~/~.
#+END_COMMENT

#+NAME: plain-links-js
#+BEGIN_SRC css :noweb yes 
  <<PRE2>><<PROTOCOL>><<PATH2>><<POST2>>
#+END_SRC

#+RESULTS: plain-links-js
: ([^\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]/)))([^\w]+?)?

********* PRE2

#+NAME: PRE2
#+BEGIN_SRC css
  ([^.\w]+?)?
#+END_SRC

********** Implementation Notes about ~PRE2~

- Added ~.~ to simplify relative file path matching.

********* PATH2

#+NAME: PATH2
#+BEGIN_SRC css
  ([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]/)))
#+END_SRC

********* POST2

#+NAME: POST2
#+BEGIN_SRC css
  ([^\w]+?)?
#+END_SRC

********* Tests - Plain Link [96%]

********** DONE Web

#+BEGIN_SRC js :cmd "node" :var data="http://www.astro.uva.nl/~dominik             on the web" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'http://www.astro.uva.nl/~dominik ',
  undefined,
  'http:',
  'http:',
  'http',
  '//www.astro.uva.nl/~dominik',
  'k',
  'k',
  ' ',
  index: 0,
  input: 'http://www.astro.uva.nl/~dominik             on the web' ]
#+END_SRC

#+BEGIN_SRC js :cmd "node" :var data="put text before http://www.astro.uva.nl/~dominik             on the web" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ ' http://www.astro.uva.nl/~dominik ',
  ' ',
  'http:',
  'http:',
  'http',
  '//www.astro.uva.nl/~dominik',
  'k',
  'k',
  ' ',
  index: 15,
  input: 'put text before http://www.astro.uva.nl/~dominik             on the web' ]
#+END_SRC


#+BEGIN_SRC js :cmd "node" :var data="put text before \nhttp://www.astro.uva.nl/~dominik             on the web" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ ' \nhttp://www.astro.uva.nl/~dominik ',
  ' \n',
  'http:',
  'http:',
  'http',
  '//www.astro.uva.nl/~dominik',
  'k',
  'k',
  ' ',
  index: 15,
  input: 'put text before \nhttp://www.astro.uva.nl/~dominik             on the web' ]
#+END_SRC

********** DONE DOI for an electronic resource

#+BEGIN_SRC js :cmd "node" :var data="doi:10.1000/182                              DOI for an electronic resource" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'doi:10.1000/182 ',
  undefined,
  'doi:',
  'doi:',
  'doi',
  '10.1000/182',
  '2',
  '2',
  ' ',
  index: 0,
  input: 'doi:10.1000/182                              DOI for an electronic resource' ]
#+END_SRC

********** DONE file, absolute path

#+BEGIN_SRC js :cmd "node" :var data="file:/home/dominik/images/jupiter.jpg        file, absolute path" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:/home/dominik/images/jupiter.jpg ',
  undefined,
  'file:',
  'file:',
  'file',
  '/home/dominik/images/jupiter.jpg',
  'g',
  'g',
  ' ',
  index: 0,
  input: 'file:/home/dominik/images/jupiter.jpg        file, absolute path' ]
#+END_SRC

#+BEGIN_SRC js :cmd "node" :var data="/home/dominik/images/jupiter.jpg             same as above" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ '/home/dominik/images/jupiter.jpg ',
  undefined,
  '/',
  undefined,
  undefined,
  'home/dominik/images/jupiter.jpg',
  'g',
  'g',
  ' ',
  index: 0,
  input: '/home/dominik/images/jupiter.jpg             same as above' ]
#+END_SRC

********** DONE file, relative path

#+BEGIN_SRC js :cmd "node" :var data="file:papers/last.pdf                         file, relative path" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:papers/last.pdf ',
  undefined,
  'file:',
  'file:',
  'file',
  'papers/last.pdf',
  'f',
  'f',
  ' ',
  index: 0,
  input: 'file:papers/last.pdf                         file, relative path' ]
#+END_SRC

#+BEGIN_SRC js :cmd "node" :var data="./papers/last.pdf                            same as above" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ './papers/last.pdf ',
  undefined,
  './',
  undefined,
  undefined,
  'papers/last.pdf',
  'f',
  'f',
  ' ',
  index: 0,
  input: './papers/last.pdf                            same as above' ]
#+END_SRC

********** DONE file, path on remote machine

#+BEGIN_SRC js :cmd "node" :var data="file:/ssh:myself@some.where:papers/last.pdf  file, path on remote machine" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:/ssh:myself@some.where:papers/last.pdf ',
  undefined,
  'file:',
  'file:',
  'file',
  '/ssh:myself@some.where:papers/last.pdf',
  'f',
  'f',
  ' ',
  index: 0,
  input: 'file:/ssh:myself@some.where:papers/last.pdf  file, path on remote machine' ]
#+END_SRC

#+BEGIN_SRC js :cmd "node" :var data="/ssh:myself@some.where:papers/last.pdf       same as above" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ '/ssh:myself@some.where:papers/last.pdf ',
  undefined,
  '/',
  undefined,
  undefined,
  'ssh:myself@some.where:papers/last.pdf',
  'f',
  'f',
  ' ',
  index: 0,
  input: '/ssh:myself@some.where:papers/last.pdf       same as above' ]
#+END_SRC

********** DONE file, jump to line number

#+BEGIN_SRC js :cmd "node" :var data="file:sometextfile::NNN                       file, jump to line number" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:sometextfile::NNN ',
  undefined,
  'file:',
  'file:',
  'file',
  'sometextfile::NNN',
  'N',
  'N',
  ' ',
  index: 0,
  input: 'file:sometextfile::NNN                       file, jump to line number' ]
#+END_SRC

********** DONE another Org file

#+BEGIN_SRC js :cmd "node" :var data="file:projects.org                            another Org file" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:projects.org ',
  undefined,
  'file:',
  'file:',
  'file',
  'projects.org',
  'g',
  'g',
  ' ',
  index: 0,
  input: 'file:projects.org                            another Org file' ]
#+END_SRC

********** DONE text search in Org file

#+BEGIN_SRC js :cmd "node" :var data="file:projects.org::some words                text search in Org file(31)" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:projects.org::some words ',
  undefined,
  'file:',
  'file:',
  'file',
  'projects.org::some words',
  ' words',
  's',
  ' ',
  index: 0,
  input: 'file:projects.org::some words                text search in Org file(31)' ]
#+END_SRC

********** DONE heading search in Org file

#+BEGIN_SRC js :cmd "node" :var data="file:projects.org::*task title               heading search in Org file(32)" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'file:projects.org::*task title ',
  undefined,
  'file:',
  'file:',
  'file',
  'projects.org::*task title',
  ' title',
  'e',
  ' ',
  index: 0,
  input: 'file:projects.org::*task title               heading search in Org file(32)' ]
#+END_SRC

********** DONE open in doc-view mode at page

#+BEGIN_SRC js :cmd "node" :var data="docview:papers/last.pdf::NNN                 open in doc-view mode at page" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'docview:papers/last.pdf::NNN ',
  undefined,
  'docview:',
  'docview:',
  'docview',
  'papers/last.pdf::NNN',
  'N',
  'N',
  ' ',
  index: 0,
  input: 'docview:papers/last.pdf::NNN                 open in doc-view mode at page' ]
#+END_SRC

********** DONE Link to heading by ID

#+BEGIN_SRC js :cmd "node" :var data="id:B7423F4D-2E8A-471B-8810-C40F074717E9      Link to heading by ID" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'id:B7423F4D-2E8A-471B-8810-C40F074717E9 ',
  undefined,
  'id:',
  'id:',
  'id',
  'B7423F4D-2E8A-471B-8810-C40F074717E9',
  '9',
  '9',
  ' ',
  index: 0,
  input: 'id:B7423F4D-2E8A-471B-8810-C40F074717E9      Link to heading by ID' ]
#+END_SRC

********** DONE Usenet link

#+BEGIN_SRC js :cmd "node" :var data="news:comp.emacs                              Usenet link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'news:comp.emacs ',
  undefined,
  'news:',
  'news:',
  'news',
  'comp.emacs',
  's',
  's',
  ' ',
  index: 0,
  input: 'news:comp.emacs                              Usenet link' ]
#+END_SRC

********** DONE Mail link

#+BEGIN_SRC js :cmd "node" :var data="mailto:adent@galaxy.net                      Mail link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'mailto:adent@galaxy.net ',
  undefined,
  'mailto:',
  'mailto:',
  'mailto',
  'adent@galaxy.net',
  't',
  't',
  ' ',
  index: 0,
  input: 'mailto:adent@galaxy.net                      Mail link' ]
#+END_SRC

********** DONE MH-E folder link

#+BEGIN_SRC js :cmd "node" :var data="mhe:folder                                   MH-E folder link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'mhe:folder ',
  undefined,
  'mhe:',
  'mhe:',
  'mhe',
  'folder',
  'r',
  'r',
  ' ',
  index: 0,
  input: 'mhe:folder                                   MH-E folder link' ]
#+END_SRC

********** DONE MH-E message link

#+BEGIN_SRC js :cmd "node" :var data="mhe:folder#id                                MH-E message link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'mhe:folder#id ',
  undefined,
  'mhe:',
  'mhe:',
  'mhe',
  'folder#id',
  'd',
  'd',
  ' ',
  index: 0,
  input: 'mhe:folder#id                                MH-E message link' ]
#+END_SRC

********** DONE RMAIL folder link

#+BEGIN_SRC js :cmd "node" :var data="rmail:folder                                 RMAIL folder link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'rmail:folder ',
  undefined,
  'rmail:',
  'rmail:',
  'rmail',
  'folder',
  'r',
  'r',
  ' ',
  index: 0,
  input: 'rmail:folder                                 RMAIL folder link' ]
#+END_SRC

********** DONE RMAIL message link

#+BEGIN_SRC js :cmd "node" :var data="rmail:folder#id                              RMAIL message link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'rmail:folder#id ',
  undefined,
  'rmail:',
  'rmail:',
  'rmail',
  'folder#id',
  'd',
  'd',
  ' ',
  index: 0,
  input: 'rmail:folder#id                              RMAIL message link' ]
#+END_SRC

********** DONE Gnus group link

#+BEGIN_SRC js :cmd "node" :var data="gnus:group                                   Gnus group link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'gnus:group ',
  undefined,
  'gnus:',
  'gnus:',
  'gnus',
  'group',
  'p',
  'p',
  ' ',
  index: 0,
  input: 'gnus:group                                   Gnus group link' ]
#+END_SRC

********** DONE Gnus article link

#+BEGIN_SRC js :cmd "node" :var data="gnus:group#id                                Gnus article link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'gnus:group#id ',
  undefined,
  'gnus:',
  'gnus:',
  'gnus',
  'group#id',
  'd',
  'd',
  ' ',
  index: 0,
  input: 'gnus:group#id                                Gnus article link' ]
#+END_SRC

********** DONE BBDB link (with regexp)

#+BEGIN_SRC js :cmd "node" :var data="bbdb:R.*Stallman                             BBDB link (with regexp)" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'bbdb:R.*Stallman ',
  undefined,
  'bbdb:',
  'bbdb:',
  'bbdb',
  'R.*Stallman',
  'n',
  'n',
  ' ',
  index: 0,
  input: 'bbdb:R.*Stallman                             BBDB link (with regexp)' ]
#+END_SRC

********** DONE IRC link

#+BEGIN_SRC js :cmd "node" :var data="irc:/irc.com/#emacs/bob                      IRC link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'irc:/irc.com/#emacs/bob ',
  undefined,
  'irc:',
  'irc:',
  'irc',
  '/irc.com/#emacs/bob',
  'b',
  'b',
  ' ',
  index: 0,
  input: 'irc:/irc.com/#emacs/bob                      IRC link' ]
#+END_SRC

********** DONE Info node or index link

#+BEGIN_SRC js :cmd "node" :var data="info:org#External links                      Info node or index link" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'info:org#External links ',
  undefined,
  'info:',
  'info:',
  'info',
  'org#External links',
  ' links',
  's',
  ' ',
  index: 0,
  input: 'info:org#External links                      Info node or index link' ]
#+END_SRC

********** DONE A shell command

#+BEGIN_SRC js :cmd "node" :var data="shell:ls *.org                               A shell command" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'shell:ls *.org ',
  undefined,
  'shell:',
  'shell:',
  'shell',
  'ls *.org',
  ' *.org',
  'g',
  ' ',
  index: 0,
  input: 'shell:ls *.org                               A shell command' ]
#+END_SRC

********** DONE Interactive Elisp command

#+BEGIN_SRC js :cmd "node" :var data="elisp:org-agenda                             Interactive Elisp command" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
[ 'elisp:org-agenda ',
  undefined,
  'elisp:',
  'elisp:',
  'elisp',
  'org-agenda',
  'a',
  'a',
  ' ',
  index: 0,
  input: 'elisp:org-agenda                             Interactive Elisp command' ]
#+END_SRC

********** TODO Elisp form to evaluate

#+BEGIN_SRC js :cmd "node" :var data="elisp:(find-file-other-frame "Elisp.org")    Elisp form to evaluate" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC js :eval never
/([^.\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}\/)([^<>\(\)\s]+((\w|\W\S)+|(?=[^\s,.!?'"\-;&]\/)))([^\w]+?)?/
null
#+END_SRC

********** zzz Empty Test Plain Link

#+BEGIN_SRC js :cmd "node" :var data="" :results replace output :var pattern=plain-links-js() :wrap "SRC js :eval never"
  let re = new RegExp(pattern);
  console.log(re)
  console.log(data.match(re))
#+END_SRC

********* Grammar

#+NAME: gen-grammar-plain-links-cson
#+BEGIN_SRC ruby :var object_link_type="plain-link" :var object_link_pattern=plain-links-js 
  object_link_template = <<-EOT
    'object-#{object_link_type.downcase}':
      'patterns':[
          {
            'match': #{object_link_pattern.inspect()}
            'captures':
              '1':
                'name': 'punctuation.definition.plain-link.begin.org-mode'
              '2':
                'name': 'markup.link.protocol.plain-link.org-mode'
              '5':
                'name': 'markup.link.path.plain-link.org-mode'
              '8':
                'name': 'punctuation.definition.plain-link.end.org-mode'
          }
      ]
  EOT
#+END_SRC

#+NAME: grammar-plain-links-cson
#+RESULTS: gen-grammar-plain-links-cson
#+begin_example
  'object-plain-link':
    'patterns':[
        {
          'match': "([^.\\w]+?)?(((b(?:bdb|ibtex)|do(?:cview|i)|e(?:lisp|shell|ww)|f(?:ile(?:[+](?:(?:emac|sy)s))?|tp)|gnus|h(?:elp|ttps?)|i(?:d|nfo|rc)|m(?:ailto|he)|news|rmail|shell|w3m):)|[.]{0,2}/)([^<>\\(\\)\\s]+((\\w|\\W\\S)+|(?=[^\\s,.!?'\"\\-;&]/)))([^\\w]+?)?"
          'captures':
            '1':
              'name': 'punctuation.definition.plain-link.begin.org-mode'
            '2':
              'name': 'markup.link.protocol.plain-link.org-mode'
            '5':
              'name': 'markup.link.path.plain-link.org-mode'
            '8':
              'name': 'punctuation.definition.plain-link.end.org-mode'
        }
    ]
#+end_example

******** Regular links

********* PATH3

- File Type
- Protocol Type
- Id Type
- Custom-Id Type
- Coderef Type
- Fuzzy Type

********* DESCRIPTION
**** Macros
   :PROPERTIES:
   :CUSTOM_ID: Macros
   :END:

   Macros follow the pattern:

   #+BEGIN_EXAMPLE
   {{{NAME(ARGUMENTS)}}}
   #+END_EXAMPLE

   NAME must start with a letter and can be followed by any number of
   alpha-numeric characters, hyphens and underscores.

   ARGUMENTS can contain anything but "}}}" string.  Values within
   ARGUMENTS are separated by commas.  Non-separating commas have to
   be escaped with a backslash character.

***** Code  

****** Regular Expressions

**** Targets and Radio Targets
   :PROPERTIES:
   :CUSTOM_ID: Targets_and_Radio_Targets
   :END:

   Radio targets follow the pattern:

   #+BEGIN_EXAMPLE
   <<<CONTENTS>>>
   #+END_EXAMPLE

   CONTENTS can be any character besides ~<~, ~>~ and "\n".  It cannot
   start or end with a whitespace character.  As far as objects go, it
   can contain text markup, entities, latex fragments, subscript and
   superscript only.

   Targets follow the pattern:

   #+BEGIN_EXAMPLE
   <<TARGET>>
   #+END_EXAMPLE

   TARGET can contain any character besides ~<~, ~>~ and "\n".  It
   cannot start or end with a whitespace character.  It cannot contain
   any object.

***** Code  

****** Regular Expressions

**** Statistics Cookies
   :PROPERTIES:
   :CUSTOM_ID: Statistics_Cookies
   :END:

   Statistics cookies follow either pattern:

   #+BEGIN_EXAMPLE
   [PERCENT%]
   [NUM1/NUM2]
   #+END_EXAMPLE

   PERCENT, NUM1 and NUM2 are numbers or the empty string.

***** Code  

****** Regular Expressions

**** Subscript and Superscript
   :PROPERTIES:
   :CUSTOM_ID: Subscript_and_Superscript
   :END:

   Pattern for subscript is:

   #+BEGIN_EXAMPLE
   CHAR_SCRIPT
   #+END_EXAMPLE

   Pattern for superscript is:

   #+BEGIN_EXAMPLE
   CHAR^SCRIPT
   #+END_EXAMPLE

   CHAR is any non-whitespace character.

   SCRIPT can be ~*~ or an expression enclosed in parenthesis
   (respectively curly brackets), possibly containing balanced
   parenthesis (respectively curly brackets).

   SCRIPT can also follow the pattern:

   #+BEGIN_EXAMPLE
   SIGN CHARS FINAL
   #+END_EXAMPLE

   SIGN is either a plus sign, a minus sign, or an empty string.

   CHARS is any number of alpha-numeric characters, commas,
   backslashes and dots, or an empty string.

   FINAL is an alpha-numeric character.

   There is no white space between SIGN, CHARS and FINAL.

***** Code  

****** Regular Expressions

**** Table Cells
   :PROPERTIES:
   :CUSTOM_ID: Table_Cells
   :END:

   Table cells follow the pattern:

   #+BEGIN_EXAMPLE
   CONTENTS SPACES|
   #+END_EXAMPLE

   CONTENTS can contain any character excepted a vertical bar.

   SPACES contains any number of space characters, including zero.  It
   can be used to align properly the table.

   The final bar may be replaced with a newline character for the last
   cell in row.

***** Code  

****** Regular Expressions

**** Timestamps
   :PROPERTIES:
   :CUSTOM_ID: Timestamp
   :END:

   There are seven possible patterns for timestamps:
   
   #+BEGIN_EXAMPLE
   <%%(SEXP)>                                                     (diary)
   <DATE TIME REPEATER-OR-DELAY>                                  (active)
   [DATE TIME REPEATER-OR-DELAY]                                  (inactive)
   <DATE TIME REPEATER-OR-DELAY>--<DATE TIME REPEATER-OR-DELAY>   (active range)
   <DATE TIME-TIME REPEATER-OR-DELAY>                             (active range)
   [DATE TIME REPEATER-OR-DELAY]--[DATE TIME REPEATER-OR-DELAY]   (inactive range)
   [DATE TIME-TIME REPEATER-OR-DELAY]                             (inactive range)
   #+END_EXAMPLE

   SEXP can contain any character excepted ~>~ and ~\n~.

   DATE follows the pattern:

   #+BEGIN_EXAMPLE
   YYYY-MM-DD DAYNAME
   #+END_EXAMPLE

   ~Y~, ~M~ and ~D~ are digits.  DAYNAME can contain any non
   whitespace-character besides ~+~, ~-~, ~]~, ~>~, a digit or ~\n~.

   TIME follows the pattern ~H:MM~.  ~H~ can be one or two digit long
   and can start with 0.

   REPEATER-OR-DELAY follows the pattern:

   #+BEGIN_EXAMPLE
   MARK VALUE UNIT
   #+END_EXAMPLE

   MARK is ~+~ (cumulate type), ~++~ (catch-up type) or ~.+~ (restart
   type) for a repeater, and ~-~ (all type) or ~--~ (first type) for
   warning delays.

   VALUE is a number.

   UNIT is a character among ~h~ (hour), ~d~ (day), ~w~ (week), ~m~
   (month), ~y~ (year).

   MARK, VALUE and UNIT are not separated by whitespace characters.

   There can be two REPEATER-OR-DELAY in the timestamp: one as
   a repeater and one as a warning delay.

***** Code  

****** Regular Expressions

**** Text Markup
   :PROPERTIES:
   :CUSTOM_ID: Emphasis_Markers
   :END:

   Text markup follows the pattern:

   #+BEGIN_EXAMPLE
   PRE MARKER CONTENTS MARKER POST
   #+END_EXAMPLE

   PRE is a whitespace character, ~(~, ~{~ ~'~ or a double quote.  It
   can also be a beginning of line.

   MARKER is a character among ~*~ (bold), ~=~ (verbatim), ~/~
   (italic), ~+~ (strike-through), ~_~ (underline), ~~~ (code).

   CONTENTS is a string following the pattern:

   #+BEGIN_EXAMPLE
   BORDER BODY BORDER
   #+END_EXAMPLE

   BORDER can be any non-whitespace character excepted ~,~, ~'~ or
   a double quote.

   BODY can contain contain any character but may not span over more
   than 3 lines.

   BORDER and BODY are not separated by whitespaces.

   CONTENTS can contain any object encountered in a paragraph when
   markup is "bold", "italic", "strike-through" or "underline".

   POST is a whitespace character, ~-~, ~.~, ~,~, ~:~, ~!~, ~?~, ~'~,
   ~)~, ~}~ or a double quote.  It can also be an end of line.

   PRE, MARKER, CONTENTS, MARKER and POST are not separated by
   whitespace characters.

   #+ATTR_ASCII: :width 5
   -----
   
   #+BEGIN_QUOTE
   All of this is wrong if ~org-emphasis-regexp-components~ or
   ~org-emphasis-alist~ are modified.

   This should really be simplified.

   Also, CONTENTS should be anything within code and verbatim
   emphasis, by definition.  --- ngz
   #+END_QUOTE

***** Code  

****** Regular Expressions 

* Export Settings                                                  :noexport:

#+OPTIONS: ':nil *:t -:t ::t <:t H:7 \n:nil ^:{} arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:nil
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t
#+TITLE: atom-org-mode-package
#+DATE: <2018-02-25 Sun>
#+AUTHOR: Brian Smith
#+EMAIL: melioratus@Brians-MacBook-Pro.local
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.3.1 (Org mode 9.1.6)

* Code                                                             :noexport:

** elisp/display-this-here

#+NAME: elisp/display-this-here
#+BEGIN_SRC elisp :var data="" 
  data
#+END_SRC

#+NAME: elisp/display-this-here-ex1
#+BEGIN_EXAMPLE
  Example Block Data
#+END_EXAMPLE

#+NAME: elisp/display-this-here-ex2
| R1C1  | R1C2  | R1C3  |
|-------+-------+-------|
| R2C1  | R2C2  | R2C3  |
| R3C1  | R3C2  | R3C3  |
| R4C1  | R4C2  | R4C3  |
| R5C1  | R5C2  | R5C3  |
| R6C1  | R6C2  | R6C3  |
| R7C1  | R7C2  | R7C3  |
| R8C1  | R8C2  | R8C3  |
| R9C1  | R9C2  | R9C3  |
#+TBLFM: @1='(format "R%sC%s" @# $#)::@1$1..@>$>='(format "R%sC%s" @# $#)


#+CALL: elisp/display-this-here(data=elisp/display-this-here-ex1)

#+RESULTS:
: Example Block Data

#+CALL: elisp/display-this-here(data=elisp/display-this-here-ex2)

#+RESULTS:
| R2C1 | R2C2 | R2C3 |
| R3C1 | R3C2 | R3C3 |
| R4C1 | R4C2 | R4C3 |
| R5C1 | R5C2 | R5C3 |
| R6C1 | R6C2 | R6C3 |
| R7C1 | R7C2 | R7C3 |
| R8C1 | R8C2 | R8C3 |
| R9C1 | R9C2 | R9C3 |

#+CALL: elisp/display-this-here(data=elisp/display-this-here-ex2) :colnames yes

#+RESULTS:
| R1C1 | R1C2 | R1C3 |
|------+------+------|
| R2C1 | R2C2 | R2C3 |
| R3C1 | R3C2 | R3C3 |
| R4C1 | R4C2 | R4C3 |
| R5C1 | R5C2 | R5C3 |
| R6C1 | R6C2 | R6C3 |
| R7C1 | R7C2 | R7C3 |
| R8C1 | R8C2 | R8C3 |
| R9C1 | R9C2 | R9C3 |

* Footnotes

[fn:1] [[https://orgmode.org/worg/dev/org-syntax.html][https://orgmode.org/worg/dev/org-syntax.html]]

[fn:2] [[https://orgmode.org/worg/dev/org-syntax.org][https://orgmode.org/worg/dev/org-syntax.org]]

[fn:3] pun intended

[fn:4] [[https://en.wikipedia.org/wiki/Literate_programming][https://en.wikipedia.org/wiki/Literate_programming]]

[fn:5] [[http://kitchingroup.cheme.cmu.edu/blog/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb/][http://kitchingroup.cheme.cmu.edu/blog/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb/]]

[fn:6] [[https://github.com/fniessen/refcard-org-mode][https://github.com/fniessen/refcard-org-mode]]

[fn:7] [[https://github.com/fniessen/org-html-themes][https://github.com/fniessen/org-html-themes]]

[fn:8] [[http://howardism.org/Technical/Emacs/literate-devops.html][http://howardism.org/Technical/Emacs/literate-devops.html]]

[fn:9] In particular, the parser requires stars at column 0 to be
quoted by a comma when they do not define a headline.

[fn:10] It also means that only headlines and sections can be
recognized just by looking at the beginning of the line.  Planning
lines and property drawers can be recognized by looking at one or two
lines above.

As a consequence, using ~org-element-at-point~ or
~org-element-context~ will move up to the parent headline, and parse
top-down from there until context around original location is found.

[fn:11] *Note:* The ~elisp:(find-file-other-frame "Elisp.org")~ pattern is not matched.

[fn:12] [[https://orgmode.org/manual/External-links.html]]

